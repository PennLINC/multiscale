---
title: "BwRSqCentric"
author: "Adam"
date: "9/7/2020"
output: github_document
---

```{r include=FALSE}
knitr::read_chunk('~/cbica/projects/pinesParcels/multiscale/scripts/analyses/correlations_over_scalesplot.R')

correlations_over_scales <- function(correlations,title){
  df<-data.frame(correlations)
  ggplot(df,aes(X1,X2)) + geom_step(size=3)+ylab(expression(rho))+
    theme_minimal(base_size = 35)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    ggtitle(title)+
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#ECB602',size=2.5)+ylim(c(-.4,.4))
}

corEstVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}

# Notice this references master E f, which has 5 fewer subjects
corEstVec_EF<-function(x){
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masteref$F1_Exec_Comp_Cog_Accuracy),as.numeric(masteref$Age),as.numeric(masteref$Sex),masteref$Motion,x))
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[5]
  return(unlist(corest))
}


### aaaand one version to just return the residuals
corResidVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[5]
  return(unlist(corest))
}

DeltaREstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x))
  colnames(scaledf)<-c('Age','Sex','Motion','varofint')
  
  # no-age model (segreg ~ sex + motion)
  noAgeGam<-gam(varofint~Sex+Motion,data=scaledf)
  # age-included model for measuring difference
  AgeGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  AgeR<-sqrt(summary(AgeGam)$r.sq)
  NoageR<-sqrt(summary(noAgeGam)$r.sq)
  dif<-AgeR-NoageR
  
  # flag negative r^2s (possible because adjusted R^2)
  if(dif<0){
    print(paste('negative delta adjusted r^2'))
  }
  
  # partial spearmans to extract age relation (for direction)
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  if(corest<0){
    dif=dif*-1
  }
  
  return(dif)
  
}

# difference in R2
DeltaR2EstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x))
  colnames(scaledf)<-c('Age','Sex','Motion','varofint')
  
  # no-age model (segreg ~ sex + motion)
  noAgeGam<-gam(varofint~Sex+Motion,data=scaledf)
  noAgeSum<-summary(noAgeGam)
  # age-included model for measuring difference
  AgeGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  AgeSum<-summary(AgeGam)
  
  dif<-AgeSum$r.sq-noAgeSum$r.sq
  
  # partial spearmans to extract age relation (for direction)
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  if(corest<0){
    dif=dif*-1
  }
  
  return(dif)
  
}

# same thing but returning chisq test sig. output for FDR correction instead of hard difference
DeltaPEstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x))
  colnames(scaledf)<-c('Age','Sex','Motion','varofint')
  
  # no-age model (segreg ~ sex + motion)
  noAgeGam<-gam(varofint~Sex+Motion,data=scaledf)
  # age-included model for measuring difference
  AgeGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  
  # test of dif with anova.gam
  anovaRes<-anova.gam(noAgeGam,AgeGam,test='Chisq')
  anovaP<-anovaRes$`Pr(>Chi)`
  anovaP2<-unlist(anovaP)
  return(anovaP2[2])
  
}
# difference in R2 for EF
EFDeltaR2EstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masteref$F1_Exec_Comp_Cog_Accuracy),as.numeric(masteref$Age),as.numeric(masteref$Sex),masteref$Motion,x))
  colnames(scaledf)<-c('EF','Age','Sex','Motion','varofint')
  
  # no-EF model (segreg ~ sex + motion)
  noEFGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  noEFSum<-summary(noEFGam)
  # age-included model for measuring difference
  EFGam<-gam(varofint~EF+Sex+Motion+s(Age,k=3),data=scaledf)
  EFSum<-summary(EFGam)
  
  dif<-EFSum$r.sq-noEFSum$r.sq
  
  # partial spearmans to extract EF relation (for direction)
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[5]
  if(corest<0){
    dif=dif*-1
  }
  
  return(dif)
  
}

# same thing but returning chisq test sig. output for FDR correction instead of hard difference
EFDeltaPEstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masteref$F1_Exec_Comp_Cog_Accuracy),as.numeric(masteref$Age),as.numeric(masteref$Sex),masteref$Motion,x))
  colnames(scaledf)<-c('EF','Age','Sex','Motion','varofint')
  
  # no-EF model (segreg ~ sex + motion)
  noEFGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  # age-included model for measuring difference
  EFGam<-gam(varofint~EF+Sex+Motion+s(Age,k=3),data=scaledf)
  
  # test of dif with anova.gam
  anovaRes<-anova.gam(noEFGam,EFGam,test='Chisq')
  anovaP<-anovaRes$`Pr(>Chi)`
  anovaP2<-unlist(anovaP)
  return(anovaP2[2])
  
}

```

```{r}
# need to 
source('~/cbica/projects/pinesParcels/multiscale/scripts/analyses/correlations_over_scalesplot_minor.R')
library(shapes)
library(ggplot2)
library(reshape2)
library(dplyr)
library(ggpubr)
library(vroom)
library(data.table)
library(mgcv)
library(ggpointdensity)
library(ppcor)
library(viridis)
library(vroom)
# load in demo
demo<-read.csv('/cbica/projects/pinesParcels/data/pnc_demo.csv')
ageSex<-data.frame(demo$ageAtScan1,as.factor(demo$sex),demo$scanid,demo$bblid)
subjects<-read.csv('/cbica/projects/pinesParcels/data/participants.txt',header = F)

###M MOTION METRIC M###
Rest_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_RestQAData_20170714.csv")
NBack_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_NBACKQAData_20181001.csv")
Idemo_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_idemo_FinalQA_092817.csv")

motmerge<-merge(Rest_Motion_Data,NBack_Motion_Data,by='bblid')
motmerge<-merge(motmerge,Idemo_Motion_Data,by='bblid')
motmerge$Motion <- (motmerge$restRelMeanRMSMotion + motmerge$nbackRelMeanRMSMotion + motmerge$idemoRelMeanRMSMotion)/3;
motiondf<-data.frame(motmerge$bblid,motmerge$Motion)
colnames(motiondf)<-c('bblid','Motion')
###M                 M###

colnames(subjects)<-c("scanid")
colnames(ageSex)<-c("Age","Sex","scanid","bblid")
df<-merge(subjects,ageSex,by="scanid")
df<-merge(df,motiondf,by='bblid')
# community solutions guaged in this iteration
community_vec<-seq(2,30)
```

```{r}
### it's rounded now bb
fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')

# take out row number row
fc<-fc[-c(1)]

# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

# AGE
masterdf<-merge(fc,df,by='bblid')

# indicators of processing stream
ind='ind'
gro='gro'
bts='bts'

# indicators of fc feature type
bwi='_bw_FC_'
wini='_win_FC_'
nsegi='_seg_scale'
gsegi='_globseg_scale'

# indices of said indicators
indiv=grep(ind,colnames(masterdf))
group=grep(gro,colnames(masterdf))
basists=grep(bts,colnames(masterdf))
bwcol=grep(bwi,colnames(masterdf))
wincols=grep(wini,colnames(masterdf))
nsegcols=grep(nsegi,colnames(masterdf))
gsegcols=grep(gsegi,colnames(masterdf))
```

```{r}

GBw=vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/globalBw_fcfeats.csv')
GWin=vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/globalWin_fcfeats.csv')

colnames(GBw)<-unlist(GBw[1,])
colnames(GWin)<-unlist(GWin[1,])

# identical parsing as above

GBw<-data.frame(GBw)
GWin<-data.frame(GWin)

# round ridiculous number of decimal points
GBw[] <- lapply(GBw, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})
GWin[] <- lapply(GWin, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})

# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

# set subjects column to bblid
colnames(GWin)[1]<-'bblid'
colnames(GBw)[1]<-'bblid'
GWindf<-merge(GWin,df,by='bblid')
GBwdf<-merge(GBw,df,by='bblid')

### isolate global columns
gWincols<-grep("globWin",colnames(GWindf))
gBwcols<-grep("globBw",colnames(GBwdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobWin<-cbind(GWindf$bblid,GWindf$Age/12,GWindf$Sex,GWindf$Motion,GWindf[,2:30])
indglobBw<-cbind(GBwdf$bblid,GBwdf$Age/12,GBwdf$Sex,GBwdf$Motion,GBwdf[,2:30])

# set colnames
colnames(indglobWin)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobBw)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobWin)[5:33]<-as.character(2:30)
colnames(indglobBw)[5:33]<-as.character(2:30)
indglobWin$Sex<-as.factor(indglobWin$Sex)
indglobBw$Sex<-as.factor(indglobBw$Sex)

# regress effect of age out on sex and motion
indglobWin_motSexC<-indglobWin
indglobBw_motSexC<-indglobBw

for (i in 5:33){
  WCLM<-lm(indglobWin[,i]~Motion+Sex,data=indglobWin)
  indglobWin_motSexC[,i]<-WCLM$residuals
  BWCLM<-lm(indglobBw_motSexC[,i]~Motion+Sex,data=indglobBw)
  indglobBw_motSexC[,i]<-BWCLM$residuals
  # add in mean for more interpretable values
  indglobWin_motSexC[,i]<-indglobWin_motSexC[,i]+mean(indglobWin[,i])
  indglobBw_motSexC[,i]<-indglobBw_motSexC[,i]+mean(indglobBw[,i])
}


# melt it
mindglobwin<-melt(indglobWin_motSexC, id=c(1,2,3,4))
mgroglobbw<-melt(indglobBw_motSexC, id=c(1,2,3,4))


WinAll<-ggplot(data=mindglobwin,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Within - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Within")

BwAll<-ggplot(data=mgroglobbw,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Bw - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Between")

### Now with motion + sex control
# 29 for scales studied
ind_GWincors<-matrix(0,29,2)
ind_GWincors[,1]<-2:30
ind_GBwcors<-matrix(0,29,2)
ind_GBwcors[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  #print(ggplot(indglobWin_motSexC,aes(Age,indglobWin_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global Win at Scale", i+1)))
  #print(ggplot(indglobBw_motSexC,aes(Age,indglobBw_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global BW at Scale", i+1)))
# relevant df
  Winscaledf<-cbind(indglobWin$Age,indglobWin$Sex,indglobWin$Motion,indglobWin[,i+4])
  Bwscaledf<-cbind(indglobBw$Age,indglobBw$Sex,indglobBw$Motion,indglobBw[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(Winscaledf,method='spearman')$estimate
  ind_GWincors[i,2]<-pspear[4]
  pspear=pcor(Bwscaledf,method='spearman')$estimate
  ind_GBwcors[i,2]<-pspear[4]
}


WinCors<-correlations_over_scales(ind_GWincors,"Global WithinCon Age Correlation")

BwCors<-correlations_over_scales(ind_GBwcors,"Global BetweenCon Age Correlation")

#ggarrange(WinAll,WinCors,BwAll,BwCors)
BwAll
BwCors
```
```{r}
### Get in Consensus-reference atlas correspondence
rac<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_yCorrespondence_overscales.csv',stringsAsFactors = F)
scalesvec<-as.numeric(rac[2,])
domnetvec<-as.factor(rac[3,])
netpropvec<-as.numeric(rac[4,])

# 17 network version
### Get in Consensus-reference atlas correspondence
rac17<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_y17Correspondence_overscales.csv',stringsAsFactors = F)
scalesvec17<-as.numeric(rac17[2,])
domnetvec17<-as.factor(rac17[3,])
netpropvec17<-as.numeric(rac17[4,])


#### read in transmodality
tm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_transmodality_overscales.csv',stringsAsFactors = F)
colnames(tm)<-tm[1,]
# aaaand remove it
tm<-tm[-c(1),]
tmvec<-as.numeric(tm)

#### read in grad2
occm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_grad2_overscales.csv',stringsAsFactors = F)
colnames(occm)<-occm[1,]
# aaaand remove it
occm<-occm[-c(1),]
occvec<-as.numeric(occm)

# distribution of transmodality across networks across scales (derived from group consensus)
hist(tmvec,12,xlab="Transmodality",ylab="Count",ylim=c(0,70), main=NULL,col="grey")

# use median transmodality value to split relatively bimodal distribution
medtrans<-median(tmvec)
# equivalent vector to be overwritten with binary classification of transmodality
tmclass<-tmvec
for (i in 1:length(tmclass)){
  if (tmvec[i]<= medtrans){
    tmclass[i]='unimodal'
  }else{
    tmclass[i]='transmodal'
  }
}
```


```{r}

### Using a ton of index combinations 
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]
# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# empty array to populate with b/w connectivity age cors (b/w to unimodal, b/w to transmodal, b/w to aggregate, and K and N and Modality just to confirm we are matching)
bwAgeCorVecs<-matrix(0,464,6)
# empty array for each nets average b/w con across subjects
bwAvgCon<-matrix(0,693,464)

# loop over connectivities to-unimodal then to-transmodal
modalloopvar=c('unimodal','transmodal')
for (i in 1:2){
  print(modalloopvar[i])
  # index "the other" (dystopian)
  modalloopvar_other=modalloopvar[modalloopvar!=(modalloopvar[i])]
  # extract which of 1:464 network mappings match the modalitity of this loop
  modalindices=which(tmclass %in% modalloopvar[i])
  # loop over each scale
    for (K in 2:30){
    # Make index of where values from this K should go
      K_start=((K-1)*(K))/2
      K_end=(((K-1)*(K))/2)+K-1
      Kind<-K_start:K_end
      bwAgeCorVecs[Kind,4]=K
    
    # index which values are at this scale
    scaleStr=paste('scale',K,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
    # extract within and between colnames at this scale for within->b/w binarized transmodality mapping
    wincolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),wincolnames)
    wincolnames_thisScale=wincolnames[wincolnames_thisScale_inds]
    bwcolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),bwcolnames)
    bwcolnames_thisScale=bwcolnames[bwcolnames_thisScale_inds]
    
    # This was to double check that the "scale" grepping was selective enough
    # print(paste(scaleStr,'number of features:',length(bwcolnames_thisScale)))
  # one weird trick to get binarized transmodality class vector for same scale (Doctors hate him!)
    # tm naming aligns with wincon naming
    tmclasses_thisScale<-tmclass[wincolnames_thisScale_inds]
    # extract the network number of each network at this scale in same order as tmclasses_thisScale
    wincolNamesSplit<-strsplit(wincolnames_thisScale,"_net")
    wincolNames_net<-sapply(wincolNamesSplit, "[[" , 2)
    # mini matching vectors with network label at this scale in one col and transmodality binarization in the other
    tmMatchingVecs<-cbind(wincolNames_net,tmclasses_thisScale)
    # remove scale number from strings so we're not picking up on those
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    bwnetnames_thisScale<-wincolNames_net<-sapply(bwcolnames_thisScale_split, "[[" , 2)
    # add another fucking set of underscores to all of these colnames so 1's dont pick up 10s
    bwnetnames_thisScale_extended<-paste('ind_bw_FC_scale',K,'_nets_',bwnetnames_thisScale,'_',sep='')
    # extra goddamn undercores have to go here and be removed later
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    # to be matched in all-networks-at-this-scale loop
    # now as we descend into the third circle of for-loop hell, we find the guy from man vs.food being eaten alive by cerberus
    for (N in 1:K){
      # generate index for where values for this network at this scale should reside
      # start from K index
      Nind<-Kind[N]
      bwAgeCorVecs[Nind,5]=N
      # get index for this N in terms of masterdf (collapse | to match multiple patterns)
      Ncolname<-grep(as.character(paste('_',N,'_',sep='')),bwnetnames_thisScale_extended,value=T)
      # need to add "_" before and after each number so I can select for '_N_' and not pick up teens digits with 1, 20s with 3, 15 and 25 with 5, etc.
      # determine if this network is transmodal or unimodal
      NModality<-tmMatchingVecs[,2][[N]]
      ########bwAgeCorVecs[Nind,6]<-NModality
      NotNModality<-modalloopvar[modalloopvar!=NModality]
      matchvec<-grep(NModality,tmclasses_thisScale)
      # remove self
      matchvec<-matchvec[matchvec!=N]
      # build index of matching modalities to reference masterdf (collapse | to match multiple patterns)
      matchTruncColName<-grep(as.character(paste('_',matchvec,'_',sep='',collapse="|")),Ncolname,value=T)
      # remove first and last characters now that we are specific
      #matchTruncColName<-sub('.$','',matchTruncColName)
      #matchTruncColName<-sub('.','',matchTruncColName)
      # deal with weird thing where empty space was being grepped because of its aspecificity at coarse scales
      if(length(matchTruncColName)==0){
        matchTruncColName[1]='CANTSEEME'
      }
      match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(matchTruncColName,collapse="|")),bwnetnames_thisScale_extended)
      match_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      
      # deal with weird thing where empty space was being grepped because of its aspecificity
      if(length(match_NetN_scaleK_bw_indivi_cols_names)==0){
        match_NetN_scaleK_bw_indivi_cols_names[1]='CANTSEEME'
      }
      #################
      #### NEED TO ADD UNDERSCORE TO AFTERPORTION SO IT DOESNT PICK UP 1_20 when looking for 1_2 #########
      ##########
      #bwcolnames_thisScale<-paste(bwcolnames_thisScale,'_',sep='')
      #match_NetN_scaleK_bw_indivi_cols_names<-paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='')
      
      # added a faux '_' to end of column to col names can more selectively match numbers (not picking up on 20 when looking for 2, 2_ and 20_ more distinct)
      match_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
    
      ###############
      ######## find opposite modality in this scale ################
      ###############
      
      oppositevec<-grep(NotNModality,tmclasses_thisScale)
      
      # build index of NON-matching modalities to reference masterdf (collapse | to match multiple patterns)
      unmatchTruncColName<-grep(as.character(paste('_',oppositevec,'_',sep='',collapse="|")),Ncolname,value=T)
      # search for string in limited bwcolnames at this scale so as not to invite other scales into this grep party
      # remove first and last characters now that we are specific
      #unmatchTruncColName<-sub('.$','',unmatchTruncColName)
      #unmatchTruncColName<-sub('.','',unmatchTruncColName)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-grep(as.character(paste(unmatchTruncColName,collapse="|")),bwnetnames_thisScale_extended,value=T)
      
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,collapse="|")),bwnetnames_thisScale_extended)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      unmatch_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
      
      
      # doublecheck that they are mutually exclusive (+1 because self-reference gets removed)
    #  if(length(tmclasses_thisScale)!=length(matchvec)+length(oppositevec)+1){
   #     print('You done goofed, internet police are on their way')
     # }
      if(length(tmclasses_thisScale)!=length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1){
        print('Names dont add up chief')
        paste('match numbas', length(match_NetN_scaleK_bw_indivi_cols_ind), length(match_NetN_scaleK_bw_indivi_cols_names))
        paste('unmatch numbas', length(unmatch_NetN_scaleK_bw_indivi_cols_ind), length(unmatch_NetN_scaleK_bw_indivi_cols_names))
        stopifnot(length(tmclasses_thisScale)==length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1)
      }
      unmatch_NetN_scaleK_bw_indivi_cols_ind
      # Reset these to NULL for each loop over N for equivalent looping
      
      
      # if it matches the modality being aggregated in the grandparent loop, we wish to only assay its connections to same-modality networks
      if (NModality==modalloopvar[i] && length(matchvec>0)){
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_same<-rowMeans(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind,drop=F])
        # get mean agecor with matching networks
        avg_bw_agecor<-corEstVec(avg_bw_same)
      } else if (NModality!=modalloopvar[i]) {  
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_dif<-rowMeans(masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
        # get mean agecor with non-matching networks
        avg_bw_agecor<-corEstVec(avg_bw_dif)
      } else if (NModality==modalloopvar[i] && (exists("matchvec[1]"))=='FALSE') {
        # easily findable index for cells which should not be filled (i.e., there is no "to unimodal connectivity" for the only unimodal networks at any scale)
        avg_bw_agecor<-999
      }
      # if it does not match the modality of the grandparent loop, we wish go assay its connections to opposite-modality networks
      bwAgeCorVecs[Nind,i]=avg_bw_agecor
    # get average bw network connectivty age correlation for this network at this scale
      both=cbind(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind],masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
      avg_bw=rowMeans(both)
      # for bw-based gams later - convert all b/w cons for a net to avg b/w for each subj
      bwAvgCon[,Nind]=avg_bw
      avg_bw_coarse_agecor<-DeltaR2EstVec(avg_bw)
      bwAgeCorVecs[Nind,3]=unlist(avg_bw_coarse_agecor)
    }
    # Print out ratio of transmodal to unimodal at this scale
    unilength=length(tmclasses_thisScale[tmclasses_thisScale=='unimodal'])
    translength=length(tmclasses_thisScale[tmclasses_thisScale=='transmodal'])
    print(paste('uni to trans ratio:', unilength/translength))
  }
  
}
bwAgeCorVecs<-data.frame(bwAgeCorVecs)
```

```{r}


# analyze between network connectivities' couplings with age by transmodality
colnames(bwAgeCorVecs)<-c('bw_to_unimodal','bw_to_transmodal','avg_bw','K','N')
############ analyze contribution of avg b/w network connectivities' age couplings by scale and transmodality #############

bwdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)

####
# avg b/w
avgbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWCor") +theme_classic(base_size = 28) + ggtitle('Correlation of Avg. Bw. Con. and Age') +guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

avgbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=scalesvec)) + geom_point(size=6) +labs(title='Correlation of Avg. Bw. Con. and Age ', x = 'Transmodality', y = "AgeBWCor", color="Topological \nScale")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")+theme(legend.position="top",legend.key.width = unit(2.5, "cm"))
####

####
# b/w to unimodal
unibw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWUCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w unimodal con and Age over All Networks')+ ylim(-.5,.5)

unibw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWUCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)
####

####
# b/w to transmodal
transbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWTCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w transmodal con and Age over All Networks')+ ylim(-.5,.5)

transbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWTCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)
####

#ggarrange(avgbw_age_tm,unibw_age_tm,transbw_age_tm,avgbw_age_scale,unibw_age_scale,transbw_age_scale)
avgbw_age_tm
unibw_age_tm
transbw_age_tm
avgbw_age_scale
unibw_age_scale
transbw_age_scale

#17 network version
bwdf17<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)

ggplot(bwdf17,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,bwAgeCorVecs.avg_bw)) + ggtitle('Age Effect by Transmodality')

```

```{r}
#### spatial props
# Both patch inf
LHpi<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/numPatches_LH_allscales.csv')
RHpi<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/numPatches_RH_allscales.csv')

# Both Patch distance info (Geodesic)
piGD<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/NetworkGeoDistr.csv')
# Euclidean distance info
piED<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/NetworkEucDistr.csv')


# bwAgeCorVecs is starting point, length 464 for each network
bwdf$LH_patchnum<-LHpi$patchnum_over_scalesL
bwdf$RH_patchnum<-RHpi$patchnum_over_scalesR
bwdf$Tot_patchnum<-bwdf$LH_patchnum+bwdf$RH_patchnum
bwdf$Transmodality<-tmvec
bwdf$bw_avg<-bwdf$bwAgeCorVecs.avg_bw

patchTM<-ggplot(bwdf,aes(Tot_patchnum,Transmodality,color=domnetvec,alpha=netpropvec^2))+ geom_point(size=5,aes(Tot_patchnum,Transmodality)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + ylab("Transmodality") + xlab("Total Patch number") +theme_classic(base_size = 28)+guides(alpha=FALSE,color=FALSE)+theme(legend.position="top",legend.title = element_blank(),axis.title.x=element_blank(), axis.text.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank())

patchAgeBw<-ggplot(bwdf,aes(Tot_patchnum,bw_avg,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=5,aes(Tot_patchnum,bw_avg))+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Total Number of Patches") + ylab("AgeBwDeltaR") +theme_classic(base_size = 28)+ ylim(-.2,.2)+guides(alpha=FALSE,color=FALSE)+theme(legend.position="top",legend.title = element_blank(),axis.title.x=element_blank(), axis.text.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank())
```


```{r}
# the distance duo
bwdf$Patch_GeoDisperse<-piGD$nwise_geods
bwdf$Patch_EucDisperse<-piED$nwise_eucs

geodAgeBw<-ggplot(bwdf,aes(Patch_GeoDisperse,bw_avg,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Geodesic Dispersion") + ylab("AgeBwDeltaR^2") +theme_classic(base_size = 28) + geom_point(size=5,aes(Patch_GeoDisperse,bw_avg))+guides(alpha=FALSE,color=FALSE)+theme(legend.position="top",legend.title = element_blank(),axis.title.x=element_blank(), axis.text.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank())

eucAgeBw<-ggplot(bwdf,aes(Patch_EucDisperse,bw_avg,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Euclidean Dispersion") + ylab("AgeBwDeltaR") +theme_classic(base_size = 28) + geom_point(size=5,aes(Patch_EucDisperse,bw_avg)) +guides(alpha=FALSE,color=FALSE)+theme(legend.position="top",legend.title = element_blank(),axis.title.x=element_blank(), axis.text.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank())

geodTM<-ggplot(bwdf,aes(Patch_GeoDisperse,Transmodality,color=domnetvec,alpha=netpropvec^2))+ geom_point(size=5,aes(Patch_GeoDisperse,Transmodality)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + ylab("Transmodality") + xlab("Geodesic Dispersion") +theme_classic(base_size = 28)+guides(alpha=FALSE,color=FALSE)+theme(legend.position="top",legend.title = element_blank(),axis.title.x=element_blank(), axis.text.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank())

eucTM<-ggplot(bwdf,aes(Patch_EucDisperse,Transmodality,color=domnetvec,alpha=netpropvec^2))+ geom_point(size=5,aes(Patch_EucDisperse,Transmodality)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + ylab("Transmodality") + xlab("Euclidean Dispersion") +theme_classic(base_size = 28)+guides(alpha=FALSE,color=FALSE)+theme(legend.position="top",legend.title = element_blank(),axis.title.x=element_blank(), axis.text.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank())
```

```{r}
# effects of transmodality above and beyond dispersion
bw_tm_dispersion<-lm(bw_avg~Transmodality+Patch_GeoDisperse+Patch_EucDisperse+Tot_patchnum,data=bwdf)
```

```{r}
# age effect duration w/ b/w
# long df - replaced indexed master df with bwAvgCon, because bwAvgCon yields network-wise measures vs. pairwise
long_precursor<-data.frame(masterdf$bblid,masterdf$Age,masterdf$Sex,masterdf$Motion,bwAvgCon)
melt_long<-melt(long_precursor,id=c(1,2,3,4))
tmvecRepped<-rep(tmvec,each=693)
domnetvecRepped<-rep(domnetvec,each=693)
melt_long$transmodality<-tmvecRepped
melt_long$dominantYeo<-domnetvecRepped
saveRDS(melt_long,file = '~/Desktop/Long_bblidAgeSexMotionAvgBw.rds')
```


```{r}
# delineate age trajectories of every net.
library(gratia)
library(dplyr)
library(svglite)
library(cowplot)
library(mgcv)
library(viridis)

covariates=" ~s(Age,k=3)+Sex+Motion"   

minAgeEst<-rep(0,length=length(masterdf[,indiv_nsegcols_ind]))
maxAgeEst<-rep(0,length=length(masterdf[,indiv_nsegcols_ind]))

derivInfo<-array(0,dim=c(464,200))
NetSplines<-array(0,dim=c(464,693))                  

# borrowing colnames from indiv_nsegcols to keep network/scale ordering/mappings
colnames(bwAvgCon)<-colnames(masterdf[,indiv_nsegcols_ind])
bwAvgCondf<-data.frame(bwAvgCon)
#add on covariate columns
bwAvgCondf$Age<-masterdf$Age
bwAvgCondf$Sex<-masterdf$Sex
bwAvgCondf$Motion<-masterdf$Motion

#for i in 464, -3 because age sex and motion columns sit at the end
for (i in 1:(length(bwAvgCondf)-3)){
  # borrowing colnames from indiv_nsegcols to keep network mappings
  x<-colnames(bwAvgCondf[i])
  form<-as.formula(paste("",x,"", covariates, sep=""))
  igam<-gam(formula = form,data=bwAvgCondf)
  derv<-derivatives(igam,term='Age')
  derv<- derv %>%
  mutate(sig = !(0 >lower & 0 < upper))
  derv$sig_deriv = derv$derivative*derv$sig
  if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
  } else {
  minAgeEst[i]<-min(derv$data[derv$sig==T])
  maxAgeEst[i]<-max(derv$data[derv$sig==T])
  # changed to sig deriv only 7/10/20
  derivInfo[i,]=derv$sig_deriv
  forSpline<-predict(igam, data = masterdf, type = "terms")
  # adding mean val because output values are centered
  colOfInt<-unlist(bwAvgCondf[,i])
  NetSplines[i,]<-forSpline[,3]+coef(igam)[1]
  if (mean(colOfInt)>0){
    print(paste(x,mean(colOfInt)))
  }
  }
  ###cat(sprintf("\nSig change: %1.2f - %1.2f\n",minAgeEst[i],maxAgeEst[i]))
}

```

```{r}
#b/w EF relations at community level

#subjbehav<-read.csv("/cbica/projects/pinesParcels/data/n713_Behavior_20181219.csv")
subjbehav<-read.csv("~/Downloads/n9498_cnb_factor_scores_fr_20170202.csv")
#ef<-data.frame(subjbehav$F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
ef<-data.frame(subjbehav$NAR_F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
colnames(ef)<-c('F1_Exec_Comp_Cog_Accuracy','bblid')
# merge in
masteref<-merge(masterdf,ef,by='bblid')


# difference in R^2
BW_R2VecEst<-as.numeric(lapply(bwAvgCondf[,1:464],EFDeltaR2EstVec))
BW_pVecEst<-as.numeric(lapply(bwAvgCondf[,1:464],EFDeltaPEstVec))
corrected<-p.adjust(BW_pVecEst,method='fdr')

# get indes of where fdr p < 0.05 so we can get some of the noisy relations out
cBW_R2VecEst<-BW_R2VecEst
cBW_R2VecEst[corrected>0.05]=0

# with FDR corrections zeroed
cbwR2EFdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,cBW_R2VecEst)

fdrzeroed<-ggplot(cbwR2EFdf,aes(tmvec,cBW_R2VecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,cBW_R2VecEst)) + ggtitle('EF Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

# without FDR corrections zeroed
bwR2EFdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,BW_R2VecEst)

raw<-ggplot(bwR2EFdf,aes(tmvec,BW_R2VecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,BW_R2VecEst)) + ggtitle('EF Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

ggplot(bwR2EFdf,aes(tmvec,BW_R2VecEst,color=scalesvec,alpha=netpropvec^2)) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,BW_R2VecEst)) + ggtitle('EF Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

########### along PG2 instead of 1

# with FDR corrections zeroed
cbwR2EFdf<-data.frame(occvec,scalesvec,domnetvec,netpropvec,cBW_R2VecEst)

fdrzeroed<-ggplot(cbwR2EFdf,aes(occvec,cBW_R2VecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("PG2") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(occvec,cBW_R2VecEst)) + ggtitle('EF Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

# without FDR corrections zeroed
bwR2EFdf<-data.frame(occvec,scalesvec,domnetvec,netpropvec,BW_R2VecEst)

raw<-ggplot(bwR2EFdf,aes(occvec,BW_R2VecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("PG2") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(occvec,BW_R2VecEst)) + ggtitle('EF Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

ggplot(bwR2EFdf,aes(occvec,BW_R2VecEst,color=scalesvec,alpha=netpropvec^2)) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,BW_R2VecEst)) + ggtitle('EF Effect by PG2')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")
```

```{r}
# years format
minAgeEst<-minAgeEst/12
maxAgeEst<-maxAgeEst/12

CIgroupingInd<-as.factor(1:464)

#convert to years for more interpretable slope
derivInfo<-derivInfo*12





# get a vector of the agespan split into 200 to match the deriv vals
agerange<-range(masterdf$Age)/12
agerange200<-seq(agerange[1],agerange[2],length.out = 200)

AgeSpan_plotdf2<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)



# needs to be converted to repeat 464 times before progressing to next age bracket
agerange200464<-array(dim=c(200*464,1))
for (i in 1:length(agerange200)){
agerange200464[((464*i)-463):(464*i)]<-rep(agerange200[i],464)
}

# now we need deriv vals of same format, but they will change for every network at every age bracket. Using sig change should take care of whitening out zeros
deriv200464<-array(dim=c(200*464,1))
for (i in 1:length(agerange200)){
deriv200464[((464*i)-463):(464*i)]<-derivInfo[,i]
}

LongAgeSpan_plotdf2<-data.frame(sapply(AgeSpan_plotdf2,rep.int,times=200))
LongAgeSpan_plotdf2$agespans<-agerange200464
LongAgeSpan_plotdf2$derivs<-deriv200464

breaks=c(-.02,-.01,0,0.01,0.02)


# older version
###ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=derivs,group=CIgroupingInd)) +geom_line(size=10,alpha=.8) +labs(title='Network Segregation Effect Span', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 58)+ xlim(c(8,23))+ scale_colour_gradientn(colours=c('#ff0a0a','#ff9191','white','#8585ff','#0b0bff'),values = c(0,.05,.265,.615,1),breaks=breaks, labels = breaks,name="Change Per Year")+theme(legend.position="top",legend.key.width = unit(4, "cm"))


bwspan<-ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=derivs,group=CIgroupingInd)) +geom_line(size=13,alpha=.8) +labs(title='External Connectivity Age Effect Span', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 58)+ xlim(c(8,23))+ scale_colour_gradientn(colours=c('#0b0bff','#8585ff','white','#ff9191','#ff0a0a'),values = c(0,.25,.5,.75,1),breaks=breaks, labels = breaks,limits=c(-.005,0.005),name="Change Per Year")+theme(legend.position="top",legend.key.width = unit(5, "cm"))





# with yeo color scheme instead
LongAgeSpan_plotdf2$domnetvec<-as.factor(LongAgeSpan_plotdf2$domnetvec)
#LongAgeSpan_plotdf2$derivs[abs(LongAgeSpan_plotdf2$derivs) < 0.002] <- 0


y7ver<-ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=domnetvec,group=CIgroupingInd,alpha=abs(derivs))) +geom_line(size=5,aes(agespans,tmvec)) +labs(title='Network Segregation Effect Manifestation', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 28)+ xlim(c(8,23))+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068'),name="Maximal Y7 Overlap")+scale_alpha_continuous(range=c(0,1))

```