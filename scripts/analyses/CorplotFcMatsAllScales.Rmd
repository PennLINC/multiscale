---
title: "AgeFCMatViz"
author: "Adam"
date: "7/23/2020"
output: html_document
---

```{r}
library(corrplot)
library(circlize)
library(ggraph)
library(igraph)
 
grid.col = c(Motor = "#3281ab", Visual = "#670068", DA = "#007500", VA = '#b61ad0', FP = "#d77d00", DM = "#c1253c", Limbic = '#007502')

col_fun=function(x) ifelse(abs(x)<.1,"#00000000",
                           ifelse(x<0,"red","blue")
)
  
for (K in 2:30){
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  AgeEfMatFn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_ageMat_K',K,'.csv',sep='')
  AgeEfMat=as.matrix(read.csv(AgeEfMatFn))
  # requires domnetvec to be ran in other rmd
  colnames(AgeEfMat)=domnetvec[Kind]
  rownames(AgeEfMat)=domnetvec[Kind]
  # get tmvec to arrange matrix by transmodality
  curTmRank<-order(tmvec[Kind])
  
  # if desired, COMMENT OUT TO OBSERVE ORIGINAL ORDER
  ReArAgeEfMat<-AgeEfMat[curTmRank,curTmRank]
  #ReArAgeEfMat<-AgeEfMat
  
  ReArAgeEfMatThresh<-ReArAgeEfMat
  ReArAgeEfMatThresh[ReArAgeEfMat > -.1 & ReArAgeEfMat < .1]=0
  corrplot(ReArAgeEfMat,is.corr = F,tl.cex = 2,cl.cex=2,cl.ratio = .3)
  
  chordDiagram(ReArAgeEfMat,grid.col = grid.col, col = col_fun,symmetric = "TRUE",annotationTrack=c("name","grid"),self.link = 1)
  title(paste(K))
  
}
```

```{r}
### For EF
#for (K in 2:30){
for (K in 3:30){
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  EF_EfMatFn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_EF_Mat_K',K,'.csv',sep='')
  EF_EfMat=as.matrix(read.csv(EF_EfMatFn))
  # requires domnetvec to be ran in other rmd
  colnames(EF_EfMat)=domnetvec[Kind]
  rownames(EF_EfMat)=domnetvec[Kind]
  # get tmvec to arrange matrix by transmodality
  curTmRank<-order(tmvec[Kind])
  ReAr_EF_EfMat<-EF_EfMat[curTmRank,curTmRank]
  ReAr_EF_EfMatThresh<-ReAr_EF_EfMat
  ReAr_EF_EfMatThresh[ReAr_EF_EfMat > -.13 & ReAr_EF_EfMat < .13]=0
  corrplot(ReAr_EF_EfMatThresh,is.corr = F,tl.cex = 2,cl.cex=2,cl.ratio = .3)
  title(paste(K))
  chordDiagram(ReAr_EF_EfMatThresh,grid.col = grid.col, col = col_fun,symmetric = "TRUE",annotationTrack=c("name","grid"),self.link = 1)
  title(paste(K))
}
  
# IN ORIG PARCEL ORDER 
for (K in 2:30){
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  EF_EfMatFn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_EF_Mat_K',K,'.csv',sep='')
  EF_EfMat=as.matrix(read.csv(EF_EfMatFn))

  # more stringent threshold
  EF_EfMat[EF_EfMat > -.13 & EF_EfMat < .13]=0
  corrplot(EF_EfMat,is.corr = F,tl.cex = 2,cl.cex=2,cl.ratio = .3)
  title(paste(K))
  #chordDiagram(ReAr_EF_EfMatThresh,grid.col = grid.col, col = col_fun,symmetric = "TRUE",annotationTrack=c("name","grid"),self.link = 1)
  #title(paste(K))
}
```

```{r}
### For Motion
for (K in 2:30){
  # current version is stripped motion model ordered by transmodality
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  Mot_EfMatFn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_Mot_Mat_K',K,'.csv',sep='')
  Mot_EfMat=as.matrix(read.csv(Mot_EfMatFn))
  # requires domnetvec to be ran in other rmd
  colnames(Mot_EfMat)=domnetvec[Kind]
  rownames(Mot_EfMat)=domnetvec[Kind]
  # get tmvec to arrange matrix by transmodality
  curTmRank<-order(Seg_CIplotdf$Patch_GeoDisperse[Kind])
  
  # by distance vector
  ReAr_Mot_EfMat<-Mot_EfMat[curTmRank,curTmRank]
  ReAr_Mot_EfMatThresh<-ReAr_Mot_EfMat
  ReAr_Mot_EfMatThresh[ReAr_Mot_EfMat > -.1 & ReAr_Mot_EfMat < .1]=0
  corrplot(ReAr_Mot_EfMatThresh,is.corr = F,tl.cex = 2,cl.cex=2,cl.ratio = .3)
  title(paste(K))
  
}

```


```{r}
### For EF Group partition values
for (K in 2:30){
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  EF_EfMatFn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_EF_Mat_K',K,'_Gro.csv',sep='')
  EF_EfMat=as.matrix(read.csv(EF_EfMatFn))
  # requires domnetvec to be ran in other rmd
  colnames(EF_EfMat)=domnetvec[Kind]
  rownames(EF_EfMat)=domnetvec[Kind]
  # get tmvec to arrange matrix by transmodality
  curTmRank<-order(tmvec[Kind])
  ReAr_EF_EfMat<-EF_EfMat[curTmRank,curTmRank]
  ReAr_EF_EfMatThresh<-ReAr_EF_EfMat
  ReAr_EF_EfMatThresh[ReAr_EF_EfMat > -.1 & ReAr_EF_EfMat < .1]=0
  corrplot(ReAr_EF_EfMatThresh,is.corr = F,tl.cex = 2,cl.cex=2,cl.ratio = .3)
  title(paste(K))
  
}
  

```

```{r}
# calc age thirds, get subject id's from oldest, middle, and youngest
quantile(masterdf$Age, c(0,.33, .66, 1))
youngids<-masterdf$bblid[masterdf$Age<177]
oldids<-masterdf$bblid[masterdf$Age>212]

# write to cluster for matlab to read
write.table(oldids,paste('/cbica/projects/pinesParcels/results/aggregated_data/OldestThirdIDs.csv',sep=''),sep=',', col.names = F,quote = F,row.names=F)
write.table(youngids,paste('/cbica/projects/pinesParcels/results/aggregated_data/YoungestThirdIDs.csv',sep=''),sep=',', col.names = F,quote = F,row.names=F)


# after matlab processing in AgeThirds_FcMats.m script, load average FC matrices back in, and re-order by transmodality

for (K in c(4,7,13,20)){
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  curTmRank<-order(tmvec[Kind])
  
  oldfn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_oldMat_K',K,'.csv',sep='')
  youngfn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_youngMat_K',K,'.csv',sep='')
  old=as.matrix(read.csv(oldfn))
  young=as.matrix(read.csv(youngfn))
  
  # Set names of rows and columns to y7 name
  colnames(old)=domnetvec[Kind]
  rownames(old)=domnetvec[Kind]
  colnames(young)=domnetvec[Kind]
  rownames(young)=domnetvec[Kind]
  
  # rearrange from unimodal to transmodal (perserve ordering with fc matrices)
  tmrankedyoung<-young[curTmRank,curTmRank]
  tmrankedold<-old[curTmRank,curTmRank]
  
  # write out averaged fc matrices (averaged across age tertiles)
  write.csv(tmrankedyoung,paste('~/Desktop/multiscale/AvgFC_young_Scale',K,'.csv',sep=''))
  write.csv(tmrankedold,paste('~/Desktop/multiscale/AvgFC_old_Scale',K,'.csv',sep=''))
  
  }



```


```{r}
d1 <- data.frame(from="origin", to=paste("group", seq(1,10), sep=""))
d2 <- data.frame(from=rep(d1$to, each=10), to=paste("subgroup", seq(1,100), sep="_"))
hierarchy <- cbind.data.frame(domnetvec,scalesvec)
 
# create a vertices data.frame. One line per object of our hierarchy, giving features of nodes.
vertices <- data.frame(name = unique(c(as.character(hierarchy$domnetvec), as.character(hierarchy$domnetvec))) ) 
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
plot(mygraph, vertex.label="", edge.arrow.size=0, vertex.size=2)
ggraph(mygraph, layout = 'dendrogram', circular = FALSE) + 
  geom_edge_link() +
  theme_void()
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
  geom_edge_diagonal() +
  theme_void()
```

```{r}

# NEEDS TO BE RUN AFTER "WITH THE SMOOTHS OVERLAID" CHUNK IN MAIN RMD

#### attempt and trendlines in corrplot, depends on stuff like the covariates call and vectors from the above chunk

# k number of factors for each df/plot, iterative over scales
# SET K DONT TRY TO RUN THIS OVER ALL Ks AT ONCE
K=4

  

  # will use k index to find approp. spot in NetSplines array
  # scratch that, netsplines array is just segreg. we need MORE
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  # scale index
  scaleind<-paste('_scale',K,'_',sep='')
  #pull cols at this scale
  
  
  
  
  
  # load in transmodality ordering to try and emulate unimodal -> tranmodal axis
  curTmRank<-order(tmvec[Kind])
  
  
  
  
  
  # for individualized only
  scaleind<-grep(scaleind,colnames(masterdf))
  scaleindivind<-intersect(scaleind,indiv)
  #make df with rows as subjects and columns as scaleindivind
  # fill it with the subject wise values from each column, then bestow colnames
  scale_df<-masterdf[scaleindivind]
  scale_df$age<-masterdf$Age
  # array for 693 gam values for each scaleindivind value (gammarray)
  gamma_ray<-array(0,c(693,length(scaleindivind)))
  
  
  
  segcols_inscaleindivind<-intersect(scaleindivind,nsegcols)
  wincols_inscaleindivind<-intersect(scaleindivind,wincols)
  bwcols_inscaleindivind<-intersect(scaleindivind,bwcol)
  
  
  # array for total psuedocorrplot
  plotarray<-t(array(as.character(paste('plot_',seq(1:(K*K)),sep='')),c(K,K)))
  segplotvec<-array(as.character(paste('Segplot_',seq(1:K),sep='')),c(K))
  
  for(i in 1:K){
    
    ##### SEGREGATION
    # fill in segregs (K segregs, gam array [1:K])
    # get position of this network in broader scale-specific individualized features index 
    posish<-grep(segcols_inscaleindivind[i],scaleindivind)
    # turn this particular FC feature into a gam
    x<-colnames(masterdf[segcols_inscaleindivind][i])
    form<-as.formula(paste("",x,"", covariates, sep=""))
    igam<-gam(formula = form,data=masterdf)
    # extract spline from igam
    derv<-derivatives(igam,term='Age')
    derv<- derv %>%
    # find where to gray out non-sig trends
    mutate(sig = !(0 >lower & 0 < upper))
    derv$sig_deriv = derv$derivative*derv$sig
    # else {
    #minAgeEst[i]<-min(derv$data[derv$sig==T])
    #maxAgeEst[i]<-max(derv$data[derv$sig==T])
    # changed to color sig deriv only
    #derivInfo[i,]=derv$sig_deriv
    forSpline<-predict(igam, data = masterdf, type = "terms")
    # adding mean val because output values are centered
    gamma_ray[,posish]<-forSpline[,3]+coef(igam)[1]
    # use linear slope from straightdforward age cor to color scheme
    scaledf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,scaleindivind[i]])
    # partial spearmans to extrac age relation
    pspear=pcor(scaledf,method='spearman')$estimate
    linear_segcor<-pspear[4]
    if (all(derv$sig==FALSE)){gamcolor='gray'
    } else if (linear_segcor>0) {gamcolor='blue'
    } else if (linear_segcor<0) {gamcolor='red'
    }
    # With the smooths overlaid
    AgeSpan_plotdf4<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
    LongAgeSpan_plotdf4<-data.frame(sapply(AgeSpan_plotdf4,rep.int,times=693))
    # port age in
    LongAgeSpan_plotdf4$Age<-masterdf$Age/12
    # ports actual splines in
    LongAgeSpan_plotdf4$SegSplines<-forSpline[,3]+coef(igam)[1]
    # will need to change this to input ggplot as a plot within a ggplot vector
    

    
    # TO INCLUDE SEG
    segplot<-ggplot(LongAgeSpan_plotdf4,aes(Age,SegSplines)) +geom_line(size=8,color=gamcolor) +labs(title=paste('Seg. Scale',K,' Net',i,sep=''), x = 'Age') +theme_classic(base_size = 28)+ xlim(c(8,23))+theme(axis.title.x=element_blank(), axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank(),axis.ticks.y=element_blank())
    
    
    # fit Seg to Segvector of plot array
    assign(segplotvec[i],segplot)
    
    #### WITHIN   
    # fill in withins (K withins, gam array [K+1:2K])
    # get position of this network in broader scale-specific individualized features index 
    posish<-grep(wincols_inscaleindivind[i],scaleindivind)
    # turn this particular FC feature into a gam
    x<-colnames(masterdf[wincols_inscaleindivind][i])
    form<-as.formula(paste("",x,"", covariates, sep=""))
    igam<-gam(formula = form,data=masterdf)
    # extract spline from igam
    derv<-derivatives(igam,term='Age')
    derv<- derv %>%
    # find where to omit non-sig trends
    mutate(sig = !(0 >lower & 0 < upper))
    derv$sig_deriv = derv$derivative*derv$sig
    #if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
    #} else {
    #minAgeEst[i]<-min(derv$data[derv$sig==T])
    #maxAgeEst[i]<-max(derv$data[derv$sig==T])
    # changed to sig deriv only
    #derivInfo[i,]=derv$sig_deriv
    forSpline<-predict(igam, data = masterdf, type = "terms")
    # adding mean val because output values are centered
    gamma_ray[,posish]<-forSpline[,3]+coef(igam)[1]
    # use linear slope from straightdforward age cor to color scheme
    scaledf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,scaleindivind[posish]])
    # partial spearmans to extract age relation
    pspear=pcor(scaledf,method='spearman')$estimate
    linear_wincor<-pspear[4]
    if (all(derv$sig==FALSE)){gamcolor='gray'
    } else if (linear_wincor>0) {gamcolor='blue'
    } else if (linear_wincor<0) {gamcolor='red'
    }
    # With the smooths overlaid
    AgeSpan_plotdf4<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
    LongAgeSpan_plotdf4<-data.frame(sapply(AgeSpan_plotdf4,rep.int,times=693))
    # port age in
    LongAgeSpan_plotdf4$Age<-masterdf$Age/12
    # ports actual splines in
    LongAgeSpan_plotdf4$WinSplines<-forSpline[,3]+coef(igam)[1]
    # will need to change this to input ggplot as a plot within a ggplot vector
    winplot<-ggplot(LongAgeSpan_plotdf4,aes(Age,WinSplines)) +geom_line(size=8,color=gamcolor) +labs(title='', x = 'Age') +theme_classic(base_size = 28)+ xlim(c(8,23))+theme(axis.title.x=element_blank(), axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank(),axis.ticks.y=element_blank())
    
    # plot specifying title code: title=paste('Net. Win. Scale',K,' Net',i,sep='')
    
    # fit WITHIN to diagonals of plot array
    plotarraywin<-diag(plotarray)
    assign(plotarraywin[i],winplot)
    
    # the big betweenchillada 
    #throw another loop in here, one segreg/win value per net but many b/w conn values
    ###  BETWEEN
    # make off diagonal plot array for filling
    # annoying fix for top triangle where it was counting sequentially over columns instead of rows 
    toptri<-t(plotarray)[lower.tri(plotarray)]
    # and bottom
    bottri<-plotarray[lower.tri(plotarray)]
    for (b in 1:length(bwcols_inscaleindivind)){
    # fill in betweens ( ((K-1)*(K))/2 betweens [2K+1: 2K + (((K-1)*(K))/2))])
    posish<-grep(bwcols_inscaleindivind[b],scaleindivind)
    x<-colnames(masterdf[bwcols_inscaleindivind][b])
    form<-as.formula(paste("",x,"", covariates, sep=""))
    igam<-gam(formula = form,data=masterdf)
    # extract spline from igam
    derv<-derivatives(igam,term='Age')
    derv<- derv %>%
    # find where to omit non-sig trends
    mutate(sig = !(0 >lower & 0 < upper))
    derv$sig_deriv = derv$derivative*derv$sig
    #if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
    #} else {
    #minAgeEst[i]<-min(derv$data[derv$sig==T])
    #maxAgeEst[i]<-max(derv$data[derv$sig==T])
    # changed to sig deriv only
    #derivInfo[i,]=derv$sig_deriv
    forSpline<-predict(igam, data = masterdf, type = "terms")
    # adding mean val because output values are centered
    gamma_ray[,posish]<-forSpline[,3]+coef(igam)[1]
    # use linear slope from straightdforward age cor to color scheme
    scaledf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,scaleindivind[posish]])
    # partial spearmans to extract age relation
    pspear=pcor(scaledf,method='spearman')$estimate
    linear_wincor<-pspear[4]
    if (all(derv$sig==FALSE)){gamcolor='gray'
    } else if (linear_wincor>0) {gamcolor='blue'
    } else if (linear_wincor<0) {gamcolor='red'
    }
    # With the smooths overlaid
    AgeSpan_plotdf4<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
    LongAgeSpan_plotdf4<-data.frame(sapply(AgeSpan_plotdf4,rep.int,times=693))
    # port age in
    LongAgeSpan_plotdf4$Age<-masterdf$Age/12
    # ports actual splines in
    LongAgeSpan_plotdf4$BwSplines<-forSpline[,3]+coef(igam)[1]
    # will need to change this to input ggplot as a plot within a ggplot vector
    bwplot<-ggplot(LongAgeSpan_plotdf4,aes(Age,BwSplines)) +geom_line(size=8,color=gamcolor) +labs(title='', x = 'Age') +theme_classic(base_size = 28)+ xlim(c(8,23))+theme(axis.title.x=element_blank(), axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.title.y=element_blank(), axis.text.y=element_blank(),axis.ticks.y=element_blank())   
    # fit BETWEEN to off-diagonals of plot array
    # get top triangle off diagonals
    assign(toptri[b],bwplot)
    assign(bottri[b],bwplot)
    }
  }
  

  
# try to rearrange according to transmodality    
ReArAgeEfMat<-plotarray[curTmRank,curTmRank]
ReArAgeSegVec<-segplotvec[curTmRank]
  
# commented out original order in favor of transmodality-ordered 
#plotvec<-c(print(plotarray,quote = F))
plotvec<-c(print(ReArAgeEfMat,quote = F))


plotveccommas<-paste(plotvec,collapse=",")

# Segregation values hopping on the tail end of this train
#SegStragglerscommas<-paste(ReArAgeSegVec,collapse=",")
#plotveccommas_seg<-paste(plotveccommas,',',SegStragglerscommas,sep='')

#ggarrangecommand<-paste('ggarrange(',plotveccommas_seg,',ncol=K,nrow=K+1)',sep='')
# without seg
ggarrangecommand<-paste('ggarrange(',plotveccommas,',ncol=K,nrow=K)',sep='')
#eval(parse(text=ggarrangecommand)) 

```
