---
title: "Multiscale_statsnfigs"
author: "Adam"
date: "6/7/2020"
output: html_document
---

```{r}
# need to 
source('~/cbica/projects/pinesParcels/multiscale/scripts/analyses/correlations_over_scalesplot_minor.R')
library(shapes)
library(ggplot2)
library(reshape2)
library(dplyr)
library(ggpubr)
library(vroom)
library(data.table)
library(mgcv)
library(ggpointdensity)
library(ppcor)
library(viridis)
# load in demo
demo<-read.csv('/cbica/projects/pinesParcels/data/pnc_demo.csv')
ageSex<-data.frame(demo$ageAtScan1,as.factor(demo$sex),demo$scanid,demo$bblid)
subjects<-read.csv('/cbica/projects/pinesParcels/data/participants.txt',header = F)

###M MOTION METRIC M###
Rest_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_RestQAData_20170714.csv")
NBack_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_NBACKQAData_20181001.csv")
Idemo_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_idemo_FinalQA_092817.csv")

motmerge<-merge(Rest_Motion_Data,NBack_Motion_Data,by='bblid')
motmerge<-merge(motmerge,Idemo_Motion_Data,by='bblid')
motmerge$Motion <- (motmerge$restRelMeanRMSMotion + motmerge$nbackRelMeanRMSMotion + motmerge$idemoRelMeanRMSMotion)/3;
motiondf<-data.frame(motmerge$bblid,motmerge$Motion)
colnames(motiondf)<-c('bblid','Motion')
###M                 M###

colnames(subjects)<-c("scanid")
colnames(ageSex)<-c("Age","Sex","scanid","bblid")
df<-merge(subjects,ageSex,by="scanid")
df<-merge(df,motiondf,by='bblid')
# community solutions guaged in this iteration
community_vec<-seq(2,30)

# load in error over scales
numiter=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_n',header = F)
iter_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_error',header = F)
recon_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/recon_error',header=F)

# bblids got rounded in matlab csvwrite in this iteration, plug ids directly in
bblids<-read.delim('/cbica/projects/pinesParcels/data/bblids.txt',header=F)
# yes, I double checked that they matched up
numiter$V1<-bblids[,1]
iter_err$V1<-bblids[,1]
recon_err$V1<-bblids[,1]

# calculate difference
dfdif=iter_err
dfdif[,2:30]=iter_err[,2:30]-recon_err[2:30]

# get ages and motion in there

colnames(iter_err)[1]<-"bblid"
colnames(numiter)[1]<-"bblid"
colnames(recon_err)[1]<-"bblid"
colnames(dfdif)[1]<-"bblid"

df_tc<-merge(df,iter_err,by="bblid")
df_ni<-merge(df,numiter,by="bblid")
df_rc<-merge(df,recon_err,by="bblid")
df_dif<-merge(df,dfdif,by="bblid")

mdata<-melt(df_tc,id=c(1,2,3,4,5))
mdatani<-melt(df_ni,id=c(1,2,3,4,5))
mdatarc<-melt(df_rc,id=c(1,2,3,4,5))
mdatadif<-melt(df_dif,id=c(1,2,3,4,5))

tc<-ggplot(data=mdata[1:5000,],aes(x=variable,y=value,group=bblid,color=Age)) +geom_step(alpha = 0.15,size=10)+ scale_color_gradient2(low = "green", mid = 'red', high = "green") + theme_minimal()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Non-recon error over scales")


ggarrange(tc,ni,dif,rc)

# plot average recon error over scales
mreconerr<-(colMeans(recon_err)[2:30])
mcrecnerrdf<-data.frame(mreconerr,community_vec)
ggplot(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec))+geom_line(col='black',size=2)+theme_minimal(base_size = 28)+ggtitle("Reconstruction Error Over Scales")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Recon. Error")

# Motion and Sex Replacing Age (characterize indep. relations before controlling for them)


# libraries just for this friggin raincloud
library(readr)
library(tidyverse)
library(ggplot2)
source("https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R")
library(plyr)
library(RColorBrewer)
library(reshape2)
raincloud_theme <- theme(
  text = element_text(size = 10),
  axis.title.x = element_text(size = 16),
  axis.title.y = element_text(size = 16),
  axis.text = element_text(size = 14),
  axis.text.x = element_text(angle = 45, vjust = 0.5),
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 16),
  legend.position = "right",
  plot.title = element_text(lineheight = .8, face = "bold", size = 16),
  panel.border = element_blank(),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  axis.line.x = element_line(colour = "black", size = 0.5, linetype = "solid"),
  axis.line.y = element_line(colour = "black", size = 0.5, linetype = "solid"))

ggplot(data = df, aes(y = Motion, x = Sex, fill = Sex)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), alpha = .8) +
    geom_point(aes(y = Motion, color = Sex), position = position_jitter(width = .15), size = .5, alpha = 0.8) +
    geom_boxplot(width = .1, outlier.shape = NA, alpha = 0.5) +
    coord_flip() +
    theme_bw() +
    raincloud_theme






############# Equiv Plots for these fine variables
tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Non-recon error over scales")

ggarrange(tc,ni,dif,rc)

tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2) + theme_minimal()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2)+ theme_minimal()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2)+ theme_minimal()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2) + theme_minimal()+labs(title="Non-recon error over scales")

ggarrange(tc,ni,dif,rc)

# plot variability over scales with recon error over scales
varoverscales=read.csv('/cbica/projects/pinesParcels/results/aggregated_data/Variability_overScales.csv')
colnames(varoverscales)=c('SoftVar','HardVar')
varoverscales$community_vec<-community_vec

# make a vector for shape in these plots
scalevec<-rep(0,times=29)
changevec<-scalevec
for (i in 2:29){
  changevec[i]<-mcrecnerrdf$mreconerr[i]-mcrecnerrdf$mreconerr[i-1]
}


shapedvec<-c(2,6,12,25)
scalevec[shapedvec]<-1

mcrecnerrdf$shape<-scalevec
mcrecnerrdf$change<-changevec

# select vector for chosen visualized scales (-1 because scales start at 2)
selectvec<-rep(0,29)
selectvec[3]<-1
selectvec[6]<-1
selectvec[12]<-1
selectvec[19]<-1
mcrecnerrdf$select<-selectvec
# make vector for scales of interest

avgrecon<-ggplot(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec,color=abs(change)))+geom_step(size=2)+theme_minimal(base_size = 28)+ggtitle("Reconstruction Error Over Scales")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Recon. Error")+scale_color_continuous(name='Decrease\nfrom prev.') + geom_point(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec,size=select*5))+guides(size=F)+theme(legend.position="left")

avgSPvar<-ggplot(data=varoverscales,aes(y=SoftVar,x=community_vec))+geom_step(col='black',size=2)+theme_minimal(base_size = 28)+ggtitle("Loading Variability (MAD)")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Avg. MAD")
avgHPvar<-ggplot(data=varoverscales,aes(y=HardVar,x=community_vec))+geom_step(col='black',size=2)+theme_minimal(base_size = 28)+ggtitle("Label Variability (Entropy)")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Avg. Entropy")

ggarrange(avgrecon,avgSPvar,nrow = 1)
```

```{r}
# load in FC features (takes about 3 minutes) - original file - not loaded in anymore because it tooks forever and new version is just rounded digits to a few decimal places

#fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')

#oldfc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_old.csv')
####### indicates it was part of (passed) check if new fc selectively replaced K=3 - can reactivate for further confirm
#fc<-fread('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')
# set colnames to matlab-printed colnames
#colnames(fc)<-unlist(fc[1,])
#colnames(oldfc)<-oldfc[1,]
# aaaand remove it
#fc<-fc[-c(1),]
#oldfc<-oldfc[-c(1),]

#fc<-data.frame(fc)

# round ridiculous number of decimal points
#fc[] <- lapply(fc, function(x) {
#  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
#})
#oldfc[] <- lapply(oldfc, function(x) {
#  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
#})

# trying to re-write the rounded version again
###write.csv(fc,'/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')

### it's rounded now bb
fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')

# take out row number row
fc<-fc[-c(1)]

# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

# AGE
masterdf<-merge(fc,df,by='bblid')


### isolate global segreg columns
gsegcols<-grep("globseg",colnames(masterdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))

# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(size=2,alpha = 0.2)+ scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ scale_colour_gradient2(low='#1B75BB',mid='orchid4',high='#FAAF40',midpoint = 15) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") +ylab("Global Segregation")
                                                                                                                                                                                                                                                                                                                          
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales pl
#plots, colored by Motion ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales plots, colored by Sex ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_step(alpha = 0.15,size=10)+ theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.1,size=2)+ theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)


# formal t.test for gro seg vs ind seg
indsegvec<-as.vector(unlist(indglobseg[,3:31]))
grosegvec<-as.vector(unlist(groglobseg[,3:31]))
t.test(indsegvec,grosegvec,paired=T)



########### Global seg after regressing out motion
# regress effect of age out on sex and motion
indglobseg_motSexC<-indglobseg
groglobseg_motSexC<-groglobseg

# Z-scored for check of my stats knowledge
indglobseg_Zs<-indglobseg

indglobseg_Zs$Age<-(indglobseg$Age-mean(indglobseg$Age))/sd(indglobseg$Age)
indglobseg_Zs$Motion<-(indglobseg$Motion-mean(indglobseg$Motion))/sd(indglobseg$Motion)

```

```{r}
# break up the big chunks

for (i in 5:33){
  CLM<-lm(indglobseg[,i]~Motion+Sex,data=indglobseg)
  indglobseg_motSexC[,i]<-CLM$residuals
  GCLM<-lm(groglobseg[,i]~Motion+Sex,data=groglobseg)
  groglobseg_motSexC[,i]<-GCLM$residuals
  # add in mean for more interpretable values
  indglobseg_motSexC[,i]<-indglobseg_motSexC[,i]+mean(indglobseg[,i])
  groglobseg_motSexC[,i]<-groglobseg_motSexC[,i]+mean(groglobseg[,i])
  
  meanval<-mean(indglobseg[,i])
  sdofvals<-sd(indglobseg[,i])
  Zvals<-(indglobseg[,i]-meanval)/sdofvals
  indglobseg_Zs[,i]<-Zvals
  
  plotdf<-data.frame((indglobseg_motSexC[,i]+mean(indglobseg[,i])),(indglobseg$Age))
  colnames(plotdf)=c('Segregation','Age')
print(ggplot(data=plotdf,aes(x=Age,y=Segregation)) +geom_point() + theme_minimal(base_size = 28)+labs(title=paste((i-3))) + scale_x_continuous(name ="Age",  breaks=seq(2, 30, 4))+ylab("Global Segregation"))
}


# mean seg and sd over scales plot
SegMeans<-NULL
SegSds<-NULL
for (i in 5:33){ # 2 because first col is name
  SegMeans[i-4]<-mean(indglobseg_motSexC[,i])
  SegSds[i-4]<-sd(indglobseg_motSexC[,i])
}

forSegplot<-data.frame(cbind(SegMeans,community_vec))
forSegplus<-data.frame(cbind(SegMeans+SegSds,community_vec))
forSegminus<-data.frame(cbind(SegMeans-SegSds,community_vec))

ggplot(forSegplot,aes(community_vec,SegMeans)) + geom_step(col="#262228", size=2) + geom_step(data=forSegplus,aes(community_vec,V1), color="#0375B4", size = 2) + geom_step(data=forSegminus,aes(community_vec,V1), color="#0375B4", size = 2)+theme_minimal(base_size = 35) +theme(panel.grid.minor = element_blank()) + xlab('# of Communities') +ylab("Global Segregation") +labs(title="Global Segregation - Individ. Partitions")
```

```{r}
mCindglobseg<-melt(indglobseg_motSexC, id=c(1,2,3,4))
mCgroglobseg<-melt(groglobseg_motSexC, id=c(1,2,3,4))



# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mCindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_step(alpha = 0.3,size=10)+ scale_color_viridis(option="D") + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")

groseg<-ggplot(data=mCgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Group Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

### Add rank plot
indglobseg_motSexCRank<-indglobseg_motSexC
for (K in 2:30){
  indglobseg_motSexCRank[,K+3]=rank(indglobseg_motSexC[,K+3])
}
mCindglobsegRank<-melt(indglobseg_motSexCRank, id=c(1,2,3,4))

ggplot(data=mCindglobsegRank,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.2)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation Rank")
```

```{r}

GBw=vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/globalBw_fcfeats.csv')
GWin=vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/globalWin_fcfeats.csv')

colnames(GBw)<-unlist(GBw[1,])
colnames(GWin)<-unlist(GWin[1,])

# identical parsing as above

GBw<-data.frame(GBw)
GWin<-data.frame(GWin)

# round ridiculous number of decimal points
GBw[] <- lapply(GBw, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})
GWin[] <- lapply(GWin, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})

# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

# set subjects column to bblid
colnames(GWin)[1]<-'bblid'
colnames(GBw)[1]<-'bblid'
GWindf<-merge(GWin,df,by='bblid')
GBwdf<-merge(GBw,df,by='bblid')

### isolate global columns
gWincols<-grep("globWin",colnames(GWindf))
gBwcols<-grep("globBw",colnames(GBwdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobWin<-cbind(GWindf$bblid,GWindf$Age/12,GWindf$Sex,GWindf$Motion,GWindf[,2:30])
indglobBw<-cbind(GBwdf$bblid,GBwdf$Age/12,GBwdf$Sex,GBwdf$Motion,GBwdf[,2:30])

# set colnames
colnames(indglobWin)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobBw)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobWin)[5:33]<-as.character(2:30)
colnames(indglobBw)[5:33]<-as.character(2:30)
indglobWin$Sex<-as.factor(indglobseg$Sex)
indglobBw$Sex<-as.factor(groglobseg$Sex)

# regress effect of age out on sex and motion
indglobWin_motSexC<-indglobWin
indglobBw_motSexC<-indglobBw

for (i in 5:33){
  WCLM<-lm(indglobWin[,i]~Motion+Sex,data=indglobWin)
  indglobWin_motSexC[,i]<-WCLM$residuals
  BWCLM<-lm(indglobBw_motSexC[,i]~Motion+Sex,data=indglobBw)
  indglobBw_motSexC[,i]<-BWCLM$residuals
  # add in mean for more interpretable values
  indglobWin_motSexC[,i]<-indglobWin_motSexC[,i]+mean(indglobWin[,i])
  indglobBw_motSexC[,i]<-indglobBw_motSexC[,i]+mean(indglobBw[,i])
}


# melt it
mindglobwin<-melt(indglobWin_motSexC, id=c(1,2,3,4))
mgroglobbw<-melt(indglobBw_motSexC, id=c(1,2,3,4))


WinAll<-ggplot(data=mindglobwin,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Within - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Within")

BwAll<-ggplot(data=mgroglobbw,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Bw - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Between")

### Now with motion + sex control
# 29 for scales studied
ind_GWincors<-matrix(0,29,2)
ind_GWincors[,1]<-2:30
ind_GBwcors<-matrix(0,29,2)
ind_GBwcors[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(indglobWin_motSexC,aes(Age,indglobWin_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global Win at Scale", i+1)))
    print(ggplot(indglobBw_motSexC,aes(Age,indglobBw_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global BW at Scale", i+1)))
  
# relevant df
  Winscaledf<-cbind(indglobWin$Age,indglobWin$Sex,indglobWin$Motion,indglobWin[,i+4])
  Bwscaledf<-cbind(indglobBw$Age,indglobBw$Sex,indglobBw$Motion,indglobBw[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(Winscaledf,method='spearman')$estimate
  ind_GWincors[i,2]<-pspear[4]
  pspear=pcor(Bwscaledf,method='spearman')$estimate
  ind_GBwcors[i,2]<-pspear[4]
}


WinCors<-correlations_over_scales(ind_GWincors,"Global WithinCon Age Correlation")

BwCors<-correlations_over_scales(ind_GBwcors,"Global BetweenCon Age Correlation")

ggarrange(WinAll,WinCors,BwAll,BwCors)
```


```{r}
# multi-scale patterning
# shape analyses

### 29 scales, 2 coordinates (x,y), and 693 subjs
globalbw<-array(0,dim=c(29,2,693))

# for each subject, fill in x and y coords. (x is constant, is scale)
for (i in 1:693){
  # 2-30 as x-axis (scales of obs.)
  globalbw[,1,i]<-seq(2,30)
  # y values as error/cost
  # seems more matlabby than characteristic of R that I have to as.x(as.x(df)) for it to work, but here we are
  globalbw[,2,i]<-as.array(as.matrix(indglobBw_motSexC[i,5:33]))
  
}

bw_procrust<-procGPA(globalbw)

shapepca(bw_procrust, pcno=1, type = "v", mag=300)

# get individ. level pc scores into df
indglobseg$pc1<-bw_procrust$scores[,1]

# find dif b/w scale 2 and 30 for simpler description of shape pc
#indglobseg$dif<-indglobseg$`2` - indglobseg$`30`
#plot(indglobseg$dif,indglobseg$Age)
```

```{r}
# model each global b/w as a log function over scales

# b/w = log_randomeffect_(scale)

# first model log(scale) to linearize age effects on global b/w
for (i in 1:693){
  globalbw[,1,i]<-log(seq(2,30))
}
```








```{r}
### get global seg cors
### Now with motion + sex control
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30
# make an "all" segcors for plotting a thousand lines down or so
ind_segcorsa<-ind_segcors
# 7/11 - testing across age ranges for that dependence
indglobseg_813<-subset(indglobseg,indglobseg$Age<13)
indglobseg_1318<-subset(indglobseg,indglobseg$Age>13 & indglobseg$Age <18)
indglobseg_1823<-subset(groglobseg,groglobseg$Age>18)
groglobseg_813<-subset(groglobseg,groglobseg$Age<13)
groglobseg_1318<-subset(groglobseg,groglobseg$Age>13 & groglobseg$Age <18)
groglobseg_1823<-subset(groglobseg,groglobseg$Age>18)

#### repeated ggpplot uses residuals, but pspear and cor over scales uses simultaneously fit spear-men
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(indglobseg_motSexC,aes(Age,indglobseg_motSexC[,i+4])) + geom_point(size=2,alpha=.3) +theme_minimal(base_size = 30)+ geom_smooth() +ylab(paste("Segreg. at Scale", i+1)))
  
  
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg$Age,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsa[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  print(ggplot(groglobseg,aes(Age,groglobseg[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Gro Global Segreg at Scale", i+1)))
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - Individ. Partitions")
groagecor<-correlations_over_scales(gro_segcors,"Global Segregation Age Correlation - Group Partitions")
ggarrange(indagecor,groagecor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
all<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales")



#### age segment-specific plots
########younguns###########
ind_segcorsy<-matrix(0,29,2)
ind_segcorsy[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_813$Age,indglobseg_813$Sex,indglobseg_813$Motion,indglobseg_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsy[i,2]<-pspear[4]
}

for (i in 1:29){
  scaledf<-cbind(groglobseg_813$Age,groglobseg_813$Sex,groglobseg_813$Motion,groglobseg_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

youngindagecor<-correlations_over_scalesplot_minor(ind_segcors,"Global Segregation Age Correlation - 8-13 Year Olds")

ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
young<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 8-13 Years")

###########mids##############
ind_segcorsm<-matrix(0,29,2)
ind_segcorsm[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_1318$Age,indglobseg_1318$Sex,indglobseg_1318$Motion,indglobseg_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsm[i,2]<-pspear[4]
}
for (i in 1:29){
  scaledf<-cbind(groglobseg_1318$Age,groglobseg_1318$Sex,groglobseg_1318$Motion,groglobseg_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

midindagecor<-correlations_over_scalesplot_minor(ind_segcors,"Global Segregation Age Correlation - 13-18 Year Olds")

ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
mid<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 13-18 Years")


###########geezers##########
ind_segcorsg<-matrix(0,29,2)
ind_segcorsg[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_1823$Age,indglobseg_1823$Sex,indglobseg_1823$Motion,indglobseg_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsg[i,2]<-pspear[4]
}

for (i in 1:29){
  scaledf<-cbind(groglobseg_1823$Age,groglobseg_1823$Sex,groglobseg_1823$Motion,groglobseg_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

oldindagecor<-correlations_over_scalesplot_minor(ind_segcors,"Global Segregation Age Correlation - 18-23 Year Olds")


ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
old<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 18-23 Years")

ageBreakDown<-ggarrange(indagecor,youngindagecor,midindagecor,oldindagecor)
gro_vs_ind<-ggarrange(all,young,mid,old)

```

```{r}
ggarrange(indseg,indagecor,WinAll,WinCors,BwAll,BwCors,ncol = 2,nrow=3)
```

```{r}
### get global seg cors FOR EF
# EF
#subjbehav<-read.csv("/cbica/projects/pinesParcels/data/n713_Behavior_20181219.csv")
subjbehav<-read.csv("~/Downloads/n9498_cnb_factor_scores_fr_20170202.csv")
#ef<-data.frame(subjbehav$F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
ef<-data.frame(subjbehav$NAR_F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
colnames(ef)<-c('F1_Exec_Comp_Cog_Accuracy','bblid')
# merge in
masteref<-merge(masterdf,ef,by='bblid')
### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Age,masteref$Sex,masteref$Motion,masteref[,2:30])
groglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Age,masteref$Sex,masteref$Motion,masteref[,5455:5483])

# set colnames
colnames(indglobseg)[1:5]<-c("bblid", "EF","Age","Sex","Motion")
colnames(groglobseg)[1:5]<-c("bblid", "EF","Age","Sex","Motion")
colnames(indglobseg)[6:34]<-as.character(2:30)
colnames(groglobseg)[6:34]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30

#### repeated ggpplot uses residuals, NOT SIMULTANEOUSLY FITTED EF COEFFICIENT AT THE MOMENT ### 
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  # relevant df
  scaledf<-cbind(indglobseg$EF,indglobseg$Age,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+5])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[5]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){

  # relevant df
  scaledf<-cbind(groglobseg$EF,groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+5])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[5]
}

indEFcor<-correlations_over_scales(ind_segcors,"Global Segregation EF Correlation - Individ. Partitions")
groEFcor<-correlations_over_scales(gro_segcors,"Global Segregation EF Correlation - Group Partitions")
ggarrange(indEFcor,groEFcor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-EF Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and EF Correlation Over Scales")

```

```{r}
### get global seg -motion cors
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30


# throw age in again (reprise)
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))


for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  linmod=lm(indglobseg[,i+4]~Age+Sex,data=indglobseg)
  motcor=(cor.test(linmod$residuals,indglobseg$Motion))$estimate
  ind_segcors[i,2]<-motcor
}
## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  linmod=lm(groglobseg[,i+4]~Age+Sex,data=groglobseg)
  motcor=(cor.test(linmod$residuals,groglobseg$Motion))$estimate
  gro_segcors[i,2]<-motcor
}

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Motion Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Motion Correlation Over Scales")
```


```{r}
### analyze relation of transmodality to segregation over scales
### Get in Consensus-reference atlas correspondence
rac<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_yCorrespondence_overscales.csv',stringsAsFactors = F)
scalesvec<-as.numeric(rac[2,])
domnetvec<-as.factor(rac[3,])
netpropvec<-as.numeric(rac[4,])

# 17 network version
### Get in Consensus-reference atlas correspondence
rac17<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_y17Correspondence_overscales.csv',stringsAsFactors = F)
scalesvec17<-as.numeric(rac17[2,])
domnetvec17<-as.factor(rac17[3,])
netpropvec17<-as.numeric(rac17[4,])


#### read in transmodality
tm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_transmodality_overscales.csv',stringsAsFactors = F)
colnames(tm)<-tm[1,]
# aaaand remove it
tm<-tm[-c(1),]
tmvec<-as.numeric(tm)

# distribution of transmodality across networks across scales (derived from group consensus)
hist(tmvec,12,xlab="Transmodality",ylab="Count",ylim=c(0,70), main=NULL,col="grey")

# use median transmodality value to split relatively bimodal distribution
medtrans<-median(tmvec)
# equivalent vector to be overwritten with binary classification of transmodality
tmclass<-tmvec
for (i in 1:length(tmclass)){
  if (tmvec[i]<= medtrans){
    tmclass[i]='unimodal'
  }else{
    tmclass[i]='transmodal'
  }
}

############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(individ_scalebywin_df)


########## 7/2/20 - changed to partial correlations to account for sex and motion for each network at each scale

#### Commented out confidence intervals for now, not a feature of the pcor package utilized
# will needs these functions throughout
###corconfinfvecupper<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[1])
###}
###corconfinfveclower<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[2])
###}

corEstVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}

# Notice this references master E f, which has 5 fewer subjects
corEstVec_EF<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$EF),as.numeric(masteref$Sex),masteref$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}


### aaaand one version to just return the residuals
corResidVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[5]
  return(unlist(corest))
}

DeltaREstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x))
  colnames(scaledf)<-c('Age','Sex','Motion','varofint')
  
  # no-age model (segreg ~ sex + motion)
  noAgeGam<-gam(varofint~Sex+Motion,data=scaledf)
  # age-included model for measuring difference
  AgeGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  AgeR<-sqrt(summary(AgeGam)$r.sq)
  NoageR<-sqrt(summary(noAgeGam)$r.sq)
  dif<-AgeR-NoageR
  
  # calculate residual sums of squares
  #noAgeRSS<-sum(noAgeGam$residuals^2)
  #AgeRSS<-sum(AgeGam$residuals^2)
  
  # calculate distance from mean (null w/o trends, same for both models since it is just based on mean)
  #MinusMeans<-(scaledf$varofint-mean(scaledf$varofint))^2
  # sum em
  #SumMinusMeans<-sum(MinusMeans)
  # convert to R^2
  #noAge_rsq<-1-(noAgeRSS/SumMinusMeans)
  #Age_rsq<-1-(AgeRSS/SumMinusMeans)
  
  # check to make sure that lm of linear gam RSS calculates
  #czechlm<-lm(varofint~Sex+Motion,data=scaledf)
  #czechsum<-summary(czechlm)
  #czech_rsq<-czechsum$r.squared
  
  #print(paste(noAge_rsq,czech_rsq))
  
  
  ## "un"square it, multiply by directionality
 #noAge_r<-sqrt(noAge_rsq)
  #Age_r<-sqrt(Age_rsq)
  #noAge_r<-noAge_rsq
  #Age_r<-Age_rsq
  # get difference in r
  #dif<-Age_r-noAge_r
  
  # partial spearmans to extract age relation (for direction)
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  if(corest<0){
    dif=dif*-1
  }
  
  return(dif)
  
}

###confvecupper<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corEstVec))
###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)
confvecdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###in_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))


# plot it
Win_age_tm<-ggplot(confvecdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale<-ggplot(confvecdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4)+labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = "AgeWinCor", color="Topological \nScale")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ scale_colour_gradient(low="#55185D", high="#ECB602")

#17 network version
confvecdf17<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,corVecEst)
Win_age_tm17<-ggplot(confvecdf17,aes(tmvec,corVecEst,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab("AgeWinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within-Network Con and Age over All Communities')+ ylim(-.5,.5)
```

```{r}
############ analyze contribution of segregation in network connectivities' age couplings by scale and transmodality #############

# pull out scale x network segregation for individualized maps
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
indiv_scalebynet_df<-masterdf[,indiv_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)

###confvecupper<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corEstVec))

RVecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],DeltaREstVec))

 ###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))

Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,corVecEst)) + ggtitle('Correlation of Net. Segreg. and Age')+ ylim(-.5,.5)+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

# without proportion
Segreg_age_tm_noprop<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec)) + geom_line(size=1,alpha=.5) + scale_color_manual(name="Predominant \nOverlapping \nYeo7 Network",values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst),alpha=.5) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5) +theme(legend.text=element_text(size=20))

Segreg_age_scale<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=scalesvec,alpha=.5)) +labs(title='Correlation of Net. Segreg. and Age ', x = 'Transmodality', y = "AgeSegregCor", color="Topological \nScale")+ geom_point(size=7,alpha=.5) +theme_classic(base_size = 45)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")+theme(legend.position="top",legend.key.width = unit(2.5, "cm"))

Segreg_age_scale_x<-ggplot(Seg_plotdf,aes(scalesvec,corVecEst,color=tmvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = '# of Communities', y = 'Segregation-Age Correlation', color="Transmodality")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 36)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")



ggarrange(Segreg_age_tm,Segreg_age_scale,Win_age_tm,Win_age_scale)

#17 network version
Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,corVecEst)
Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab(expression(paste(R[SegAge]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,corVecEst)) + ggtitle('Age Effect by Transmodality')+ ylim(-.5,.5)+guides(alpha=FALSE,color=guide_legend(title="Maximal Y17 Overlap"))+theme(legend.position="top")


Seg_plotdf_rdif<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,RVecEst)

# difference in R
Segreg_age_tm_rdif<-ggplot(Seg_plotdf_rdif,aes(tmvec,RVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab(expression(paste(Delta,sqrt(R^2[adj])))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,RVecEst)) + ggtitle('Age Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

# difference in R2
DeltaR2EstVec<-function(x){
  
  # relevant df
  scaledf<-data.frame(cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x))
  colnames(scaledf)<-c('Age','Sex','Motion','varofint')
  
  # no-age model (segreg ~ sex + motion)
  noAgeGam<-gam(varofint~Sex+Motion,data=scaledf)
  noAgeSum<-summary(noAgeGam)
  # age-included model for measuring difference
  AgeGam<-gam(varofint~Sex+Motion+s(Age,k=3),data=scaledf)
  AgeSum<-summary(AgeGam)
  
  dif<-AgeSum$r.sq-noAgeSum$r.sq
  
  # partial spearmans to extract age relation (for direction)
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  if(corest<0){
    dif=dif*-1
  }
  
  return(dif)
  
}

R2VecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],DeltaR2EstVec))
Seg_plotdf_r2dif<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,R2VecEst)

Segreg_age_tm_r2dif<-ggplot(Seg_plotdf_r2dif,aes(tmvec,R2VecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,R2VecEst)) + ggtitle('Age Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

AgeEff_TM<-ggarrange(Segreg_age_tm,Segreg_age_tm_rdif,Segreg_age_tm_r2dif,ncol=3)


# smooths overlaid versions for residual comparison
Segreg_age_tm_smooth<-ggplot(Seg_plotdf,aes(tmvec,corVecEst)) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 45) + geom_point(size=7) + ggtitle('Correlation of Net. Segreg. and Age')+ ylim(-.5,.5)+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top") + geom_smooth(method='loess')

Segreg_age_tm_rdif_smooth<-ggplot(Seg_plotdf_rdif,aes(tmvec,RVecEst))+ xlab("Transmodality") + ylab(expression(paste(Delta,sqrt(R^2[adj])))) +theme_classic(base_size = 45) + geom_point(size=7) + ggtitle('Age Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top") + geom_smooth(method='loess')

Segreg_age_tm_r2dif_smooth<-ggplot(Seg_plotdf_r2dif,aes(tmvec,R2VecEst)) + xlab("Transmodality") + ylab(expression(paste(Delta,R^2[adj]))) +theme_classic(base_size = 45) + geom_point(size=7) + ggtitle('Age Effect by Transmodality')+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")+ geom_smooth(method='loess')

AgeEff_TM<-ggarrange(Segreg_age_tm,Segreg_age_tm_rdif,Segreg_age_tm_r2dif,Segreg_age_tm_smooth,Segreg_age_tm_rdif_smooth,Segreg_age_tm_r2dif_smooth,ncol=3,nrow=2)
```

```{r}
# long df
long_precursor<-data.frame(masterdf$bblid,masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,indiv_nsegcols_ind])
melt_long<-melt(long_precursor,id=c(1,2,3,4))
tmvecRepped<-rep(tmvec,each=693)
domnetvecRepped<-rep(domnetvec,each=693)
melt_long$transmodality<-tmvecRepped
melt_long$dominantYeo<-domnetvecRepped
saveRDS(melt_long,file = '~/Desktop/Long_bblidAgeSexMotionSegreg.rds')
```


```{r}
# delineate age trajectories of every net.
library(gratia)
library(dplyr)
library(svglite)
library(cowplot)
library(mgcv)
library(viridis)

covariates=" ~s(Age,k=3)+Sex+Motion"   

minAgeEst<-rep(0,length=length(masterdf[,indiv_nsegcols_ind]))
maxAgeEst<-rep(0,length=length(masterdf[,indiv_nsegcols_ind]))

derivInfo<-array(0,dim=c(464,200))
NetSplines<-array(0,dim=c(464,693))                  



#for i in 464
for (i in 1:length(masterdf[,indiv_nsegcols_ind])){
  x<-colnames(masterdf[,indiv_nsegcols_ind][i])
  form<-as.formula(paste("",x,"", covariates, sep=""))
  igam<-gam(formula = form,data=masterdf)
  derv<-derivatives(igam,term='Age')
  derv<- derv %>%
  mutate(sig = !(0 >lower & 0 < upper))
  derv$sig_deriv = derv$derivative*derv$sig
  if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
  } else {
  minAgeEst[i]<-min(derv$data[derv$sig==T])
  maxAgeEst[i]<-max(derv$data[derv$sig==T])
  # changed to sig deriv only 7/10/20
  derivInfo[i,]=derv$sig_deriv
  forSpline<-predict(igam, data = masterdf, type = "terms")
  # adding mean val because output values are centered
  colOfInt<-unlist(masterdf[,indiv_nsegcols_ind][i])
  NetSplines[i,]<-forSpline[,3]+coef(igam)[1]
  if (mean(colOfInt)<.3){
    print(paste(x,mean(colOfInt)))
  }
  }
  ###cat(sprintf("\nSig change: %1.2f - %1.2f\n",minAgeEst[i],maxAgeEst[i]))
}

# years format
minAgeEst<-minAgeEst/12
maxAgeEst<-maxAgeEst/12

CIgroupingInd<-as.factor(1:464)

#convert to years for more interpretable slope
derivInfo<-derivInfo*12





# get a vector of the agespan split into 200 to match the deriv vals
agerange<-range(masterdf$Age)/12
agerange200<-seq(agerange[1],agerange[2],length.out = 200)

AgeSpan_plotdf2<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)



# needs to be converted to repeat 464 times before progressing to next age bracket
agerange200464<-array(dim=c(200*464,1))
for (i in 1:length(agerange200)){
agerange200464[((464*i)-463):(464*i)]<-rep(agerange200[i],464)
}

# now we need deriv vals of same format, but they will change for every network at every age bracket. Using sig change should take care of whitening out zeros
deriv200464<-array(dim=c(200*464,1))
for (i in 1:length(agerange200)){
deriv200464[((464*i)-463):(464*i)]<-derivInfo[,i]
}

LongAgeSpan_plotdf2<-data.frame(sapply(AgeSpan_plotdf2,rep.int,times=200))
LongAgeSpan_plotdf2$agespans<-agerange200464
LongAgeSpan_plotdf2$derivs<-deriv200464

breaks=c(-.02,-.01,0,0.01,0.02)


# older version
###ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=derivs,group=CIgroupingInd)) +geom_line(size=10,alpha=.8) +labs(title='Network Segregation Effect Span', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 58)+ xlim(c(8,23))+ scale_colour_gradientn(colours=c('#ff0a0a','#ff9191','white','#8585ff','#0b0bff'),values = c(0,.05,.265,.615,1),breaks=breaks, labels = breaks,name="Change Per Year")+theme(legend.position="top",legend.key.width = unit(4, "cm"))


segspan<-ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=derivs,group=CIgroupingInd)) +geom_line(size=13,alpha=.8) +labs(title='Network Segregation Effect Span', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 58)+ xlim(c(8,23))+ scale_colour_gradientn(colours=c('#0b0bff','#8585ff','white','#ff9191','#ff0a0a'),values = c(0,.25,.5,.75,1),breaks=breaks, labels = breaks,limits=c(-.02,0.02),name="Change Per Year")+theme(legend.position="top",legend.key.width = unit(5, "cm"))





# with yeo color scheme instead
LongAgeSpan_plotdf2$domnetvec<-as.factor(LongAgeSpan_plotdf2$domnetvec)
#LongAgeSpan_plotdf2$derivs[abs(LongAgeSpan_plotdf2$derivs) < 0.002] <- 0


y7ver<-ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=domnetvec,group=CIgroupingInd,alpha=abs(derivs))) +geom_line(size=5,aes(agespans,tmvec)) +labs(title='Network Segregation Effect Manifestation', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 28)+ xlim(c(8,23))+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068'),name="Maximal Y7 Overlap")+scale_alpha_continuous(range=c(0,1))

```

```{r}
# With the smooths overlaid
AgeSpan_plotdf3<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
LongAgeSpan_plotdf3<-data.frame(sapply(AgeSpan_plotdf3,rep.int,times=693))


# assign same transmodality value to each point on same lines
Transmodality693464<-array(dim=c(693*464,1))
for (i in 1:464){
Transmodality693464[((693*i)-692):(693*i)]<-tmvec[i]
}
LongAgeSpan_plotdf3$Transmodality<-Transmodality693464

# grouping index so all points of same line have CIgroupingInd in common
GroupingInd693464<-array(dim=c(693*464,1))
for (i in 1:464){
GroupingInd693464[((693*i)-692):(693*i)]<-CIgroupingInd[i]
}

LongAgeSpan_plotdf3$Grouping<-GroupingInd693464


# ports actual splines in
NetSplines693464<-array(dim=c(693*464,1))
for (i in 1:464){
NetSplines693464[((693*i)-692):(693*i)]<-NetSplines[i,]
}
LongAgeSpan_plotdf3$Splines<-NetSplines693464


# put this guy through the same wrangling ringer as the "estimated age", which is how the spline is ported in

NetSplinesAgeSideCar693464<-array(dim=c(693*464,1))
for (i in 1:464){
NetSplinesAgeSideCar693464[((693*i)-692):(693*i)]<-masterdf$Age
}
LongAgeSpan_plotdf3$Age<-NetSplinesAgeSideCar693464/12




# [1:4851] plots first 7 networks (693 points for each)
ggplot(LongAgeSpan_plotdf3,aes(Age,Splines,color=Transmodality,group=Grouping)) +geom_line(size=1,alpha=.1) +labs(title='Network Segregation Effect Manifestation', x = 'Age', y = 'Predicted Segregation') +theme_classic(base_size = 28)+ xlim(c(8,23))+ scale_colour_gradient(low="#55185D", high="#ECB602")

```




```{r}

### Using a ton of index combinations 
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]
# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# empty array to populate with b/w connectivity age cors (b/w to unimodal, b/w to transmodal, b/w to aggregate, and K and N and Modality just to confirm we are matching)
bwAgeCorVecs<-matrix(0,464,6)

# loop over connectivities to-unimodal then to-transmodal
modalloopvar=c('unimodal','transmodal')
for (i in 1:2){
  print(modalloopvar[i])
  # index "the other" (dystopian)
  modalloopvar_other=modalloopvar[modalloopvar!=(modalloopvar[i])]
  # extract which of 1:464 network mappings match the modalitity of this loop
  modalindices=which(tmclass %in% modalloopvar[i])
  # loop over each scale
    for (K in 2:30){
    # Make index of where values from this K should go
      K_start=((K-1)*(K))/2
      K_end=(((K-1)*(K))/2)+K-1
      Kind<-K_start:K_end
      bwAgeCorVecs[Kind,4]=K
    
    # index which values are at this scale
    scaleStr=paste('scale',K,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
    # extract within and between colnames at this scale for within->b/w binarized transmodality mapping
    wincolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),wincolnames)
    wincolnames_thisScale=wincolnames[wincolnames_thisScale_inds]
    bwcolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),bwcolnames)
    bwcolnames_thisScale=bwcolnames[bwcolnames_thisScale_inds]
    
    # This was to double check that the "scale" grepping was selective enough
    # print(paste(scaleStr,'number of features:',length(bwcolnames_thisScale)))
  # one weird trick to get binarized transmodality class vector for same scale (Doctors hate him!)
    # tm naming aligns with wincon naming
    tmclasses_thisScale<-tmclass[wincolnames_thisScale_inds]
    # extract the network number of each network at this scale in same order as tmclasses_thisScale
    wincolNamesSplit<-strsplit(wincolnames_thisScale,"_net")
    wincolNames_net<-sapply(wincolNamesSplit, "[[" , 2)
    # mini matching vectors with network label at this scale in one col and transmodality binarization in the other
    tmMatchingVecs<-cbind(wincolNames_net,tmclasses_thisScale)
    # remove scale number from strings so we're not picking up on those
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    bwnetnames_thisScale<-wincolNames_net<-sapply(bwcolnames_thisScale_split, "[[" , 2)
    # add another fucking set of underscores to all of these colnames so 1's dont pick up 10s
    bwnetnames_thisScale_extended<-paste('ind_bw_FC_scale',K,'_nets_',bwnetnames_thisScale,'_',sep='')
    # extra goddamn undercores have to go here and be removed later
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    # to be matched in all-networks-at-this-scale loop
    # now as we descend into the third circle of for-loop hell, we find the guy from man vs.food being eaten alive by cerberus
    for (N in 1:K){
      # generate index for where values for this network at this scale should reside
      # start from K index
      Nind<-Kind[N]
      bwAgeCorVecs[Nind,5]=N
      # get index for this N in terms of masterdf (collapse | to match multiple patterns)
      Ncolname<-grep(as.character(paste('_',N,'_',sep='')),bwnetnames_thisScale_extended,value=T)
      # need to add "_" before and after each number so I can select for '_N_' and not pick up teens digits with 1, 20s with 3, 15 and 25 with 5, etc.
      # determine if this network is transmodal or unimodal
      NModality<-tmMatchingVecs[,2][[N]]
      ########bwAgeCorVecs[Nind,6]<-NModality
      NotNModality<-modalloopvar[modalloopvar!=NModality]
      matchvec<-grep(NModality,tmclasses_thisScale)
      # remove self
      matchvec<-matchvec[matchvec!=N]
      # build index of matching modalities to reference masterdf (collapse | to match multiple patterns)
      matchTruncColName<-grep(as.character(paste('_',matchvec,'_',sep='',collapse="|")),Ncolname,value=T)
      # remove first and last characters now that we are specific
      #matchTruncColName<-sub('.$','',matchTruncColName)
      #matchTruncColName<-sub('.','',matchTruncColName)
      # deal with weird thing where empty space was being grepped because of its aspecificity at coarse scales
      if(length(matchTruncColName)==0){
        matchTruncColName[1]='CANTSEEME'
      }
      match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(matchTruncColName,collapse="|")),bwnetnames_thisScale_extended)
      match_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      
      # deal with weird thing where empty space was being grepped because of its aspecificity
      if(length(match_NetN_scaleK_bw_indivi_cols_names)==0){
        match_NetN_scaleK_bw_indivi_cols_names[1]='CANTSEEME'
      }
      #################
      #### NEED TO ADD UNDERSCORE TO AFTERPORTION SO IT DOESNT PICK UP 1_20 when looking for 1_2 #########
      ##########
      #bwcolnames_thisScale<-paste(bwcolnames_thisScale,'_',sep='')
      #match_NetN_scaleK_bw_indivi_cols_names<-paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='')
      
      # added a faux '_' to end of column to col names can more selectively match numbers (not picking up on 20 when looking for 2, 2_ and 20_ more distinct)
      match_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
    
      ###############
      ######## find opposite modality in this scale ################
      ###############
      
      oppositevec<-grep(NotNModality,tmclasses_thisScale)
      
      # build index of NON-matching modalities to reference masterdf (collapse | to match multiple patterns)
      unmatchTruncColName<-grep(as.character(paste('_',oppositevec,'_',sep='',collapse="|")),Ncolname,value=T)
      # search for string in limited bwcolnames at this scale so as not to invite other scales into this grep party
      # remove first and last characters now that we are specific
      #unmatchTruncColName<-sub('.$','',unmatchTruncColName)
      #unmatchTruncColName<-sub('.','',unmatchTruncColName)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-grep(as.character(paste(unmatchTruncColName,collapse="|")),bwnetnames_thisScale_extended,value=T)
      
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,collapse="|")),bwnetnames_thisScale_extended)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      unmatch_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
      
      
      # doublecheck that they are mutually exclusive (+1 because self-reference gets removed)
    #  if(length(tmclasses_thisScale)!=length(matchvec)+length(oppositevec)+1){
   #     print('You done goofed, internet police are on their way')
     # }
      if(length(tmclasses_thisScale)!=length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1){
        print('Names dont add up chief')
        paste('match numbas', length(match_NetN_scaleK_bw_indivi_cols_ind), length(match_NetN_scaleK_bw_indivi_cols_names))
        paste('unmatch numbas', length(unmatch_NetN_scaleK_bw_indivi_cols_ind), length(unmatch_NetN_scaleK_bw_indivi_cols_names))
        stopifnot(length(tmclasses_thisScale)==length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1)
      }
      unmatch_NetN_scaleK_bw_indivi_cols_ind
      # Reset these to NULL for each loop over N for equivalent looping
      
      
      # if it matches the modality being aggregated in the grandparent loop, we wish to only assay its connections to same-modality networks
      if (NModality==modalloopvar[i] && length(matchvec>0)){
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_same<-rowMeans(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind,drop=F])
        # get mean agecor with matching networks
        avg_bw_agecor<-corEstVec(avg_bw_same)
      } else if (NModality!=modalloopvar[i]) {  
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_dif<-rowMeans(masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
        # get mean agecor with non-matching networks
        avg_bw_agecor<-corEstVec(avg_bw_dif)
      } else if (NModality==modalloopvar[i] && (exists("matchvec[1]"))=='FALSE') {
        # easily findable index for cells which should not be filled (i.e., there is no "to unimodal connectivity" for the only unimodal networks at any scale)
        avg_bw_agecor<-999
      }
      # if it does not match the modality of the grandparent loop, we wish go assay its connections to opposite-modality networks
      bwAgeCorVecs[Nind,i]=avg_bw_agecor
    # get average bw network connectivty age correlation for this network at this scale
      both=cbind(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind],masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
      avg_bw=rowMeans(both)
      avg_bw_coarse_agecor<-DeltaR2EstVec(avg_bw)
      bwAgeCorVecs[Nind,3]=unlist(avg_bw_coarse_agecor)
    }
    # Print out ratio of transmodal to unimodal at this scale
    unilength=length(tmclasses_thisScale[tmclasses_thisScale=='unimodal'])
    translength=length(tmclasses_thisScale[tmclasses_thisScale=='transmodal'])
    print(paste('uni to trans ratio:', unilength/translength))
  }
  
}
bwAgeCorVecs<-data.frame(bwAgeCorVecs)
```
```{r}
# temp version
tmumRatVec<-c(1,2,1,0.666666666666667,1,.75,1.6667,1.25,1,0.833333,1.4,1.1667,1,1.5,1.2857,1.125,1,1.375,1.222,1.1,1,.9166667,.846,1.0833,.8571,.8,1,.8125,.6666)
```


```{r}


# analyze between network connectivities' couplings with age by transmodality
colnames(bwAgeCorVecs)<-c('bw_to_unimodal','bw_to_transmodal','avg_bw','K','N')
############ analyze contribution of avg b/w network connectivities' age couplings by scale and transmodality #############

# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)
bwdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)

####
# avg b/w
avgbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWCor") +theme_classic(base_size = 28) + ggtitle('Correlation of Avg. Bw. Con. and Age') + ylim(-.5,.5)+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")

avgbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=scalesvec)) + geom_point(size=6) +labs(title='Correlation of Avg. Bw. Con. and Age ', x = 'Transmodality', y = "AgeBWCor", color="Topological \nScale")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")+theme(legend.position="top",legend.key.width = unit(2.5, "cm"))
####

####
# b/w to unimodal
unibw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWUCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w unimodal con and Age over All Networks')+ ylim(-.5,.5)

unibw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWUCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)
####

####
# b/w to transmodal
transbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWTCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w transmodal con and Age over All Networks')+ ylim(-.5,.5)

transbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWTCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)
####

ggarrange(avgbw_age_tm,unibw_age_tm,transbw_age_tm,avgbw_age_scale,unibw_age_scale,transbw_age_scale)

#17 network version
bwdf17<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)

Segreg_age_tm17<-ggplot(bwdf17,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab("AgeB/WCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,bwAgeCorVecs.avg_bw)) + ggtitle('Correlation of B/w Con Avg and Age over All Communities')+ ylim(-.5,.5)
```


```{r}
# attempt to regress out b/w effects from transmodal-segregation relation
#### INCOMPLETE
# multi-stage regression because segreg is built on between - take residuals from between modeling

# get residuals of b/w-age relations 

corEstVecBwRegr<-function(x,y){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,y,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[5]
  return(unlist(corest))
}

#bwdf$bwAgeCorVecs.avg_bw

#corVecEstBwControl<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corEstVecBwRegr))

###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
#CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))

#Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

#Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 45) + geom_point(size=7,aes(tmvec,corVecEst)) + ggtitle('Correlation of Net. Segreg. and Age')+ ylim(-.5,.5)+guides(alpha=FALSE,color=guide_legend(title="Maximal Y7 Overlap"))+theme(legend.position="top")


```





```{r}
#### now make it for group template-measured FC vaues, starting with within and segreg
############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
gro_wincols_ind<-intersect(wincols,group)
group_scalebynet_df<-masterdf[,gro_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(group_scalebynet_df)


#confvecupper<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfvecupper))
#confveclower<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,gro_wincols_ind],corEstVec))
#confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
#confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
GWin_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
#corVecEst_d[,6]<-CIgroupingInd

# plot it
Win_age_tm_gro<-ggplot(GWin_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Connectivity and Age over All Networks (GRO)')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale_gro<-ggplot(GWin_plotdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# pull out scale x network segregation for individualized maps
gro_nsegcols_ind<-intersect(nsegcols,group)
gro_scalebynet_df<-masterdf[,gro_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(gro_scalebynet_df)

corVecEst<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corEstVec))

GSeg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

Segreg_age_tm_gro<-ggplot(GSeg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Segregation and Age over All Networks (GRO)')+ ylim(-.5,.5)

Segreg_age_scale_gro<-ggplot(GSeg_plotdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)


ggarrange(Segreg_age_tm_gro,Segreg_age_scale_gro,Win_age_tm_gro,Win_age_scale_gro)
```

```{r}

# quick plot of each vertices' change in age-org relation over scales and transmodality
f=read.csv('/cbica/projects/pinesParcels/results/aggregated_data/ScaleAgeWin_TM_interaction.csv')
library(ggpointdensity)
ggplot(f,aes(x=CMTM,y=Var2)) + geom_pointdensity(adjust=.5) + scale_color_viridis_c() +xlab('Transmodality') + ylab('Change in Age-Within Relation (Slope) over Scales')

within_verts<-ggplot(f,aes(x=CMTM,y=Var2,color=Var2)) + geom_point(shape=4,alpha=.4,size=1) +xlab('Transmodality') + ylab('Coarse-to-fine Correlation Slope')+theme_classic(base_size=28)+scale_color_gradient2(low='blue',mid='gray',high='red',name='Change')+theme(legend.position="none",legend.key.width = unit(2.5, "cm"))

# and for Between
f2=read.csv('/cbica/projects/pinesParcels/results/aggregated_data/ScaleAgeBw_TM_interaction.csv')
ggplot(f2,aes(x=CMTM,y=Var2)) + geom_pointdensity(adjust=.3) + scale_color_viridis_c() +xlab('Transmodality') + ylab('Change in Age-Between Relation (Slope) over Scales')


# modulated position = none in and out for legend grab
between_verts<-ggplot(f2,aes(x=CMTM,y=Var2,color=Var2)) + geom_point(shape=4,alpha=.4,size=1) +xlab('Transmodality') + ylab('Coarse-to-fine Correlation Slope')+theme_classic(base_size=28)+scale_color_gradient2(low='blue',mid='gray',high='red',name='Change')+theme(legend.position="none",legend.key.width = unit(2.5, "cm"))


ggarrange(within_verts,between_verts)


# regress out tm effect
plotLM<-gam(Var2~s(CMTM,k=3),data=f2)
f2$resid<-plotLM$residuals
ggplot(f2,aes(x=CMTM,y=resid,color=Var2)) + geom_point(shape=4,alpha=.4,size=1) +xlab('Transmodality') + ylab('Coarse-to-fine Correlation Slope')+theme_classic(base_size=28)+scale_color_gradient2(low='blue',mid='gray',high='red',name='Change')+theme(legend.position="none",legend.key.width = unit(2.5, "cm"))
```


```{r}
# Framework for pairwise age patterns
# Transmodality Dif and Age-relation
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]

# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# initialize empty tm difference vector and age effect vector 
tmdifvec=NULL
ageEfvec=NULL
motionEfvec=NULL
motioncorvec<-NULL

# make a scale vector to match transmodality difference values
# this is to look at how finer scales confer networks that are less different
scalevec=NULL

# make a vector of variables that can become plots
pointwise_bwplotvec<-t(array(as.character(paste('plot_',seq(1:7),sep='')),c(1,7)))


# quick write of colnames for bw features for all scales as sep. files for matlab reading

for (k in 2:30){
    # index which values are at this scale
    scaleStr=paste('scale',k,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
    # print colnames
    scalebwcolnames<-colnames(masterdf[scaleK_bw_indivi_cols_inds])
  # write list of b/w col names for matching in matlab
    write.table(scalebwcolnames,paste('/cbica/projects/pinesParcels/results/aggregated_data/Scale',k,'_Ind_bwColnames.csv',sep=''),sep=',', col.names = F,quote = F,row.names=F)
}    


#### This measures all the pairwise distances for the plots
## for all b/w cols
for (i in 1:length(colnames(individ_scalebybw_df))){
    # extract column name. Will parse column name to determine nature of #connection
    curcolname<-colnames(individ_scalebybw_df)[i]
    splitname<-unlist(strsplit(curcolname,'_'))
    scalefield=splitname[4]
    net1field=splitname[5]
    net2field=splitname[7]
    # doctor up scale and net1field so they are exclusively the value of #interest
    scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
    net1=unlist(strsplit(net1field,'s'))[2]
    net2=net2field 
    # helping phriendly index
    K_start=((scale-1)*(scale))/2
    K_end=(((scale-1)*(scale))/2)+scale-1
    Kind<-K_start:K_end
    # get TM values of both nets at this scale
    tm1=tmvec[Kind[as.numeric(net1)]]
    tm2=tmvec[Kind[as.numeric(net2)]]
    # absolute value as directionality is meaningless here
    tmdif=abs(tm1-tm2)
    # get position in master df of this column (need to use \b for exact matches #only)
    curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
    colindex<-grep(curcolnameexact,colnames(masterdf))
    # get Age relation controlling for sex and motion
    pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex])
    # partial spearmans to extrac age relation
    pspear=pcor(pcordf,method='spearman')$estimate
    # save both to respective vectors
    tmdifvec<-append(tmdifvec,tmdif)
    ageEfvec<-append(ageEfvec,pspear[4])
    motionEfvec<-append(motionEfvec,pspear[3,4])
    motioncorvec<-append(motioncorvec,cor.test(masterdf[,colindex],masterdf$Motion)$estimate)
    # accompanying scalevec so we can look at the typical transmodality #difference at each scale
    scalevec=append(scalevec,scale)
}

## merged vectors
BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)

ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + geom_point(alpha=.07,size=5) + xlab('Transmodality Difference') + ylab('Age #Correlation') + ggtitle('Pairwise Between-Network Age-FC Relations')

# combine scalevec and transmodality dif vec for transmodality difference #differences
ScaleTMDifDf<-data.frame(tmdifvec,scalevec)
ScaleTMDifMeanVec<-rep(0,29)
for (K in 2:30){
  # Pull out values at this scale
  ScaleDF<-ScaleTMDifDf[ScaleTMDifDf$scalevec==K,]
  # Average Values at this scale (K-1 because 1st scale is 2)
  ScaleTMDifMeanVec[K-1]=mean(ScaleDF$tmdifvec)
  }
    
plot(ScaleTMDifMeanVec)

ggplot(ScaleTMDifDf,aes(x=scalevec,y=tmdifvec)) + geom_point(alpha=.1,size=2) +xlab('Number of Communities') + ylab('B/W Transmodality Difference')

######### Look at between-distance relations

## grab matlab-generated euclidean distance vector, match to age effect vector
distance_array=array(dim=c(length(colnames(individ_scalebybw_df)),2))

# make a between over scales vector to keep track of where each between feature sits in the whole multiscale combination
bw_over_scales=NULL
bw_start=0
bw_end=0


for (k in 2:30){
    # index which values are at this scale
    scaleStr=paste('scale',k,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)

    # load in distance file for this scale
    disfp=paste('/cbica/projects/pinesParcels/results/aggregated_data/Scale',k,'_Ind_bwColnames_andDist.csv',sep='')
    distancedf<-read.csv(disfp)
    # check to make sure name in file is the same as the corresponding bw col from masterdf
    if (identical((colnames(masterdf)[scaleK_bw_indivi_cols_inds]),distancedf$bwcolscell_1)){
      print('bw column names match')}
    print(k)
    
    # helping phriendly index ## NEED TO MAKE B/W INDEX
    bw_start=bw_end+1
    bw_end=bw_start+((k)*(k-1)/2)-1
    Bwind<-bw_start:bw_end
    
    distance_array[Bwind,1]<-colnames(masterdf)[scaleK_bw_indivi_cols_inds]
    distance_array[Bwind,2]<-distancedf$bwcolscell_2
    
}  

# Add in pairwise distance between communities, motion-FC relation
BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec,as.numeric(distance_array[,2]),motionEfvec,motioncorvec)

colnames(BwAgeCorTMDifDf)<-c('TMDif','AgeEf','EucDist','MotionEf','MotionCor')

# Artificial 0s exist where 2 communities do not exist on the same hemisphere, mask em out
BwAgeCorDistance_nonZero<-BwAgeCorTMDifDf[BwAgeCorTMDifDf$EucDist!=0,]

ggplot(data=BwAgeCorDistance_nonZero,aes(x=EucDist,y=AgeEf)) + geom_point(alpha=.07,size=5) + xlab('Euclid. Dist.') + ylab('Age #Correlation') + ggtitle('Pairwise Between-Network Age-FC Relations')

ggplot(data=BwAgeCorDistance_nonZero,aes(x=EucDist,y=MotionEf)) + geom_point(alpha=.07,size=5) + xlab('Euclid. Dist.') + ylab('Motion Partial Correlation') + ggtitle('Pairwise Between-Network Motion-FC Relations')

ggplot(data=BwAgeCorDistance_nonZero,aes(x=EucDist,y=MotionCor)) + geom_point(alpha=.07,size=5) + xlab('Euclid. Dist.') + ylab('Motion  Correlation') + ggtitle('Pairwise Between-Network Motion-FC Relations')
```

```{r}
# seperate out types of pairwise connections to see if unimodal networks reach out over larger transmodality gaps to integrate over age (if transmodality is a measure of how "DMN" a region is, it will underestimate intrinsic differences between things like motor and visual if they are equally "non-dmn" )

# make a vector of each y7 network so i can loop over it instead of makingn 7 different loops
Y7vec<-c('Motor','Visual','DA','VA','Limbic','FP','DM')
# set yeo colorset
ycolors=c('#3281ab','#670068','#007500','#b61ad0','#b8cf86','#d77d00','#c1253c')

#
## for all y7 nets
#for (y in 1:7){
#  # net looked at in this iteration
#  print(Y7vec[y])
#  tmdifvec=NULL
#  ageEfvec=NULL
#  # isolate this net by getting indices of where it is in the 464 vector
#  curY7NetInd<-grep(Y7vec[y],domnetvec)
#  # for all b/w cols
#  for (i in 1:length(colnames(individ_scalebybw_df))){
#      #print(i)
#      # extract column name. Will parse column name to determine nature of #connection
#      curcolname<-colnames(individ_scalebybw_df)[i]
#      splitname<-unlist(strsplit(curcolname,'_'))
#      scalefield=splitname[4]
#      net1field=splitname[5]
#      net2field=splitname[7]
#      # doctor up scale and net1field so they are exclusively the value of #interestx
#      scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
#      net1=unlist(strsplit(net1field,'s'))[2]
#      net2=net2field 
#      # helping phriendly index
#      K_start=((scale-1)*(scale))/2
#      K_end=(((scale-1)*(scale))/2)+scale-1
#      Kind<-K_start:K_end
#      # ONLY include if one network is equal to currently indexed Y7 network
#      y7lab1=domnetvec[Kind[as.numeric(net1)]]
#      y7lab2=domnetvec[Kind[as.numeric(net2)]]
#      if (y7lab1 == Y7vec[y] || y7lab2 == Y7vec[y]){
#      # get TM values of both nets at this scale
#      tm1=tmvec[Kind[as.numeric(net1)]]
#      tm2=tmvec[Kind[as.numeric(net2)]]
#      # absolute value as directionality is meaningless here
#      tmdif=abs(tm1-tm2)
#      # get position in master df of this column (need to use \b for exact #matches only)
#      curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
#      colindex<-grep(curcolnameexact,colnames(masterdf))
#      # get Age relation controlling for sex and motion
#      pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex#])
#      # partial spearmans to extrac age relation
#      pspear=pcor(pcordf,method='spearman')$estimate
#      # save both to respective vectors
#      tmdifvec<-append(tmdifvec,tmdif)
#      ageEfvec<-append(ageEfvec,pspear[4])
#      }
#  }
#  # merged vectors
#  BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)
#  print(ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + #geom_point(alpha=.17,size=5) + xlab('Transmodality Difference') +  ylim(-.4,.4) #+xlim(-.1,13)+ ylab('Age Correlation') + ggtitle(paste('Pairwise Between-Network #Age-FC Relations - ',Y7vec[y]))) 
#}

# for all y7 nets (EXCLUSIVE VERSION)

for (y in 1:7){
  # net looked at in this iteration
  print(Y7vec[y])
  # color used for this iter
  itercolor=ycolors[y]
  tmdifvec=NULL
  ageEfvec=NULL
  # isolate this net by getting indices of where it is in the 464 vector
  curY7NetInd<-grep(Y7vec[y],domnetvec)
  # for all b/w cols
  for (i in 1:length(colnames(individ_scalebybw_df))){
      #print(i)
      # extract column name. Will parse column name to determine nature of connection
      curcolname<-colnames(individ_scalebybw_df)[i]
      splitname<-unlist(strsplit(curcolname,'_'))
      scalefield=splitname[4]
      net1field=splitname[5]
      net2field=splitname[7]
      # doctor up scale and net1field so they are exclusively the value of interestx
      scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
      net1=unlist(strsplit(net1field,'s'))[2]
      net2=net2field 
      # helping phriendly index
      K_start=((scale-1)*(scale))/2
      K_end=(((scale-1)*(scale))/2)+scale-1
      Kind<-K_start:K_end
      # ONLY exclude if one network is equal to currently indexed Y7 network ( manipulate here to run on all)
      y7lab1=domnetvec[Kind[as.numeric(net1)]]
      y7lab2=domnetvec[Kind[as.numeric(net2)]]
      if (y7lab1 != Y7vec[y] && y7lab2 != Y7vec[y]){
      # get TM values of both nets at this scale
      tm1=tmvec[Kind[as.numeric(net1)]]
      tm2=tmvec[Kind[as.numeric(net2)]]
      # absolute value as directionality is meaningless here
      tmdif=abs(tm1-tm2)
      # get position in master df of this column (need to use \b for exact matches only)
      curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
      colindex<-grep(curcolnameexact,colnames(masterdf))
      # get Age relation controlling for sex and motion
      pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex])
      # partial spearmans to extrac age relation
      pspear=pcor(pcordf,method='spearman')$estimate
      # save both to respective vectors
      tmdifvec<-append(tmdifvec,tmdif)
      ageEfvec<-append(ageEfvec,pspear[4])
      }
  }
  # get correlation
  correl=cor.test(tmdifvec,ageEfvec)
  cor_of_int=round(correl$estimate,3)
  # merged vectors
  BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)
  bwplot<-ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + geom_point(alpha=.17,size=5)+ 
  geom_smooth(method='lm',linetype="dashed",color=itercolor,size=2) + xlab('Transmodality Difference') +  ylim(-.4,.4) +xlim(-.1,13)+ ylab('Age Correlation') + ggtitle(paste('B/w-Network Age-FC Relations - ',Y7vec[y], ' excluded',sep=''))+geom_text(x=11,y=.3,label=paste('r =', cor_of_int))
  
assign(pointwise_bwplotvec[y],bwplot)

}

#ggarrange(plot_1,plot_2,plot_3,plot_4,plot_5,plot_6,plot_7)

ggarrange(plot_1,plot_7)

```


```{r}
# Segregation controlling for between-to-unimodal connectivity

# functions to control for covariates in linear model framework 
#BetWeen UniModal Control
lmEstVecBWUMC<-function(x,foursixfourindex){
  # extract corresponding between network connectivity
  bwAgeCorVecs$
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

```

```{r}
# get the gang together (write out vectors of network metric effect relations)
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
gro_nsegcols_ind<-intersect(nsegcols,group)

# functions to write out the corvec estimates for matlab-based viz
pcorEstVecNsave<-function(x,K,vecIn){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

pcorEstVec_EFNsave<-function(x,K,vecIn){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$F1_Exec_Comp_Cog_Accuracy),as.numeric(masteref$Sex),masteref$Motion,as.numeric(masteref$Age),as.numeric(x))
  # partial spearmans to extract age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[5])
  append(vecIn,corest)
}

# get residuals (constant over loops)
# loop over scales
for (i in 2:30){
  print(i)
  keyphrase<-paste('seg_scale',as.character(i),'_net',sep='')
  scaleind=grep(keyphrase,colnames(masterdf))
  # just individualized for now
  # reads in vector of segreg vals aligned with age vals and scale 
  vec_age<-NULL
  vec_age<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],pcorEstVecNsave,K=i,vecIn=vec_age)
  vecfp_Age<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_Age.csv',sep='')
  write.table(as.numeric(vec_age),vecfp_Age,row.names = F,col.names = F,sep = ',')
  vec_ef<-NULL
  vec_efi<-lapply(masteref[,intersect(indiv_nsegcols_ind,scaleind)],pcorEstVec_EFNsave,K=i,vecIn=vec_ef)
  vecfp_EFi<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_EF_i.csv',sep='')
  write.table(as.numeric(vec_efi),vecfp_EFi,row.names = F,col.names = F,sep = ',')
  vec_ef<-NULL
  vec_efg<-lapply(masteref[,intersect(gro_nsegcols_ind,scaleind)],pcorEstVec_EFNsave,K=i,vecIn=vec_ef)
  vecfp_EFg<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_EF_g.csv',sep='')
  write.table(as.numeric(vec_efg),vecfp_EFg,row.names = F,col.names = F,sep = ',')
}

# Write em out as matlab readable vectors (K: N1est N2est ... Nnest)
```

```{r}
# same approach to write normative segregation for each network at each scale
SegEstVecNsave<-function(x,K,vecIn){
  # relevant df
  meanSeg<-mean(x)
  append(vecIn,meanSeg)
}

# loop over scales
for (i in 2:30){
  print(i)
  keyphrase<-paste('seg_scale',as.character(i),'_net',sep='')
  scaleind=grep(keyphrase,colnames(masterdf))
  # just individualized for now
  # reads in vector of segreg vals aligned with age vals and scale 
  vec_Seg<-NULL
  vec_Seg<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],SegEstVecNsave,K=i,vecIn=vec_Seg)
  vecfp_Seg<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_mSeg.csv',sep='')
  write.table(as.numeric(vec_Seg),vecfp_Seg,row.names = F,col.names = F,sep = ',')
}
```

```{r}
# longer effect vectors for vertex-wisepc
# also need matlab-reading capacity
#library(rmatio)
#pospc=read.mat('/cbica/projects/pinesParcels/results/aggregated_data/vwise_pospc_allscales_allsubjs.mat')
#h5 can support this file format, but this r does not support h5

### screw it we're regressing in matlab
forMLpc<-cbind(masterdf$bblid,masterdf$Age,masterdf$Motion,masterdf$Sex)
MPpcFN<-'/cbica/projects/pinesParcels/results/EffectVecs/forMLpc.csv'
write.table(forMLpc,MPpcFN,row.names = F,col.names = F,sep = ',')

### screw it we're regressing in matlab
forML_EF<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Age,masteref$Motion,masteref$Sex)
MP_EFFN<-'/cbica/projects/pinesParcels/results/EffectVecs/forML_EF.csv'
write.table(forML_EF,MP_EFFN,row.names = F,col.names = F,sep = ',')

forPMACS_EF<-cbind(masteref$sc,masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Age,masteref$Motion,masteref$Sex)
MP_EFFN<-'/cbica/projects/pinesParcels/results/EffectVecs/forML_EF.csv'
write.table(forML_EF,MP_EFFN,row.names = F,col.names = F,sep = ',')

# permuted version 1
set.seed(1)
permuted_ind<-sample(1:693)
permuted_age<-masterdf$Age[permuted_ind]
forMLpc_permut<-cbind(masterdf$bblid,permuted_age,masterdf$Motion,masterdf$Sex)
MPpcFN_permut<-'/cbica/projects/pinesParcels/results/EffectVecs/forMLpc_permut.csv'
write.table(forMLpc_permut,MPpcFN_permut,row.names = F,col.names = F,sep = ',')


# permuted version 1 - EF
set.seed(1)
permuted_ind<-sample(1:693)
permuted_ef<-masteref$F1_Exec_Comp_Cog_Accuracy[permuted_ind]
forML_EFpermut<-cbind(masteref$bblid,permuted_ef,masteref$Age,masteref$Motion,masteref$Sex)
MP_EF_FN_permut<-'/cbica/projects/pinesParcels/results/EffectVecs/forML_EF_permut.csv'
write.table(forML_EFpermut,MP_EF_FN_permut,row.names = F,col.names = F,sep = ',')

# FC vecs
for (i in 2:30){
  scaleind<-grep((paste('scale',i,'_',sep='')),colnames(masterdf))
  print(paste('scale',str(i),'number of fc features:',length(scaleind)))
  forRRfc<-cbind(masterdf$Age,masterdf$Motion,masterdf[,scaleind])
  RRfcFN<-paste('/cbica/projects/pinesParcels/results/EffectVecs/scale',i,'forRRfc.csv',sep='')
  write.table(forRRfc,RRfcFN,row.names = F,col.names = F,sep = ',')
}
```

```{r}
# global b/w network trend over scales for comparison to global seg
##### MAY BE REDUNDANT - MAINTAIN IF YOU WANT MORE R CONTROL OVER DATA SUBSETTING
# 9/2/20 - global b/w for comparison
# extract mean b/w as well
# 693 by 29 array for mean b/w values at each scale
gbw<-array(0,dim=c(693,29))

indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]

# seperate run for K=2 to avoid rowMeans error message on single row
K=2
scaleStr=paste('scale',K,'_',sep='')
scaleCols_inds=grep(scaleStr,colnames(masterdf))
scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
# put within subject average into global array. K=1 because scales start at 2
gbw[,(K-1)]=masterdf[,scaleK_bw_indivi_cols_inds]
  
for (K in 3:30){
# index b/w value colum
  scaleStr=paste('scale',K,'_',sep='')
  scaleCols_inds=grep(scaleStr,colnames(masterdf))
  scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
  # put within subject average into global array. K=1 because scales start at 2
  gbw[,(K-1)]=rowMeans(masterdf[,scaleK_bw_indivi_cols_inds])
}

# merge it all together
indglobbw<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,gbw)
```











