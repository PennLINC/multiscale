---
title: "Multiscale_statsnfigs"
author: "Adam"
date: "6/7/2020"
output: html_document
---

```{r}
library(shapes)
library(ggplot2)
library(reshape2)
library(dplyr)
library(ggpubr)
library(data.table)
library(mgcv)
library(ggpointdensity)
library(ppcor)
# load in demo
demo<-read.csv('/cbica/projects/pinesParcels/data/pnc_demo.csv')
ageSex<-data.frame(demo$ageAtScan1,as.factor(demo$sex),demo$scanid,demo$bblid)
subjects<-read.csv('/cbica/projects/pinesParcels/data/participants.txt',header = F)

###M MOTION METRIC M###
Rest_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_RestQAData_20170714.csv")
NBack_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_NBACKQAData_20181001.csv")
Idemo_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_idemo_FinalQA_092817.csv")

motmerge<-merge(Rest_Motion_Data,NBack_Motion_Data,by='bblid')
motmerge<-merge(motmerge,Idemo_Motion_Data,by='bblid')
motmerge$Motion <- (motmerge$restRelMeanRMSMotion + motmerge$nbackRelMeanRMSMotion + motmerge$idemoRelMeanRMSMotion)/3;
motiondf<-data.frame(motmerge$bblid,motmerge$Motion)
colnames(motiondf)<-c('bblid','Motion')
###M                 M###

colnames(subjects)<-c("scanid")
colnames(ageSex)<-c("Age","Sex","scanid","bblid")
df<-merge(subjects,ageSex,by="scanid")
df<-merge(df,motiondf,by='bblid')
# community solutions guaged in this iteration
community_vec<-seq(2,30)

# load in error over scales
numiter=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_n',header = F)
iter_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_error',header = F)
recon_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/recon_error',header=F)

# bblids got rounded in matlab csvwrite in this iteration, plug ids directly in
bblids<-read.delim('/cbica/projects/pinesParcels/data/bblids.txt',header=F)
# yes, I double checked that they matched up
numiter$V1<-bblids[,1]
iter_err$V1<-bblids[,1]
recon_err$V1<-bblids[,1]

# calculate difference
dfdif=iter_err
dfdif[,2:30]=iter_err[,2:30]-recon_err[2:30]

# get ages and motion in there

colnames(iter_err)[1]<-"bblid"
colnames(numiter)[1]<-"bblid"
colnames(recon_err)[1]<-"bblid"
colnames(dfdif)[1]<-"bblid"

df_tc<-merge(df,iter_err,by="bblid")
df_ni<-merge(df,numiter,by="bblid")
df_rc<-merge(df,recon_err,by="bblid")
df_dif<-merge(df,dfdif,by="bblid")

mdata<-melt(df_tc,id=c(1,2,3,4,5))
mdatani<-melt(df_ni,id=c(1,2,3,4,5))
mdatarc<-melt(df_rc,id=c(1,2,3,4,5))
mdatadif<-melt(df_dif,id=c(1,2,3,4,5))

tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Non-recon error over scales")


ggarrange(tc,ni,dif,rc)

# plot average recon error over scales
mreconerr<-(colMeans(recon_err)[2:30])
mcrecnerrdf<-data.frame(mreconerr,community_vec)
ggplot(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec))+geom_line(col='white',size=2)+theme_dark(base_size = 28)+ggtitle("Reconstruction Error Over Scales")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Recon. Error")

# Motion and Sex Replacing Age (characterize indep. relations before controlling for them)


# libraries just for this friggin raincloud
library(readr)
library(tidyverse)
library(ggplot2)
source("https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R")
library(plyr)
library(RColorBrewer)
library(reshape2)
raincloud_theme <- theme(
  text = element_text(size = 10),
  axis.title.x = element_text(size = 16),
  axis.title.y = element_text(size = 16),
  axis.text = element_text(size = 14),
  axis.text.x = element_text(angle = 45, vjust = 0.5),
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 16),
  legend.position = "right",
  plot.title = element_text(lineheight = .8, face = "bold", size = 16),
  panel.border = element_blank(),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  axis.line.x = element_line(colour = "black", size = 0.5, linetype = "solid"),
  axis.line.y = element_line(colour = "black", size = 0.5, linetype = "solid"))

ggplot(data = df, aes(y = Motion, x = Sex, fill = Sex)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), alpha = .8) +
    geom_point(aes(y = Motion, color = Sex), position = position_jitter(width = .15), size = .5, alpha = 0.8) +
    geom_boxplot(width = .1, outlier.shape = NA, alpha = 0.5) +
    coord_flip() +
    theme_bw() +
    raincloud_theme






############# Equiv Plots for these fine variables
tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Non-recon error over scales")

ggarrange(tc,ni,dif,rc)

tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2) + theme_dark()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2)+ theme_dark()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2)+ theme_dark()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2) + theme_dark()+labs(title="Non-recon error over scales")

ggarrange(tc,ni,dif,rc)
```

```{r}
# load in FC features (takes about 3 minutes) - original file - not loaded in anymore because it tooks forever and new version is just rounded digits to a few decimal places

#fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')
#######oldfc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_old.csv')
####### indicates it was part of (passed) check if new fc selectively replaced K=3 - can reactivate for further confirm
fc<-fread('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')
# set colnames to matlab-printed colnames
colnames(fc)<-unlist(fc[1,])
#######colnames(oldfc)<-oldfc[1,]
# aaaand remove it
fc<-fc[-c(1),]
#######oldfc<-oldfc[-c(1),]

fc<-data.frame(fc)

# round ridiculous number of decimal points
fc[] <- lapply(fc, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})
#######oldfc[] <- lapply(oldfc, function(x) {
#######  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
#######})



# Baal knows why vroom needs more size for the rounded version
#Sys.setenv("VROOM_CONNECTION_SIZE" = 2000000)
#fc<-read.delim('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')
# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

### merge FC with subj info
colnames(fc)[1]<-'bblid'
# AGE
masterdf<-merge(fc,df,by='bblid')


### isolate global segreg columns
gsegcols<-grep("globseg",colnames(masterdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))

# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales plots, colored by Motion ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales plots, colored by Sex ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.1,size=2)+ theme_dark(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.1,size=2)+ theme_dark(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)


# formal t.test for gro seg vs ind seg
indsegvec<-as.vector(unlist(indglobseg[,3:31]))
grosegvec<-as.vector(unlist(groglobseg[,3:31]))
t.test(indsegvec,grosegvec,paired=T)



########### Global seg after regressing out motion
# regress effect of age out on sex and motion
indglobseg_motSexC<-indglobseg
groglobseg_motSexC<-groglobseg

# Z-scored for check of my stats knowledge
indglobseg_Zs<-indglobseg

indglobseg_Zs$Age<-(indglobseg$Age-mean(indglobseg$Age))/sd(indglobseg$Age)
indglobseg_Zs$Motion<-(indglobseg$Motion-mean(indglobseg$Motion))/sd(indglobseg$Motion)

for (i in 5:33){
  CLM<-lm(indglobseg[,i]~Motion+Sex,data=indglobseg)
  indglobseg_motSexC[,i]<-CLM$residuals
  GCLM<-lm(groglobseg[,i]~Motion+Sex,data=groglobseg)
  groglobseg_motSexC[,i]<-GCLM$residuals
  
  
  meanval<-mean(indglobseg[,i])
  sdofvals<-sd(indglobseg[,i])
  Zvals<-(indglobseg[,i]-meanval)/sdofvals
  indglobseg_Zs[,i]<-Zvals
}


mCindglobseg<-melt(indglobseg_motSexC, id=c(1,2,3,4))
mCgroglobseg<-melt(groglobseg_motSexC, id=c(1,2,3,4))



# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mCindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")

groseg<-ggplot(data=mCgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Group Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)
```


```{r}
### get global seg cors
### Now with motion + sex control
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30

#### repeated ggpplot uses residuals, but pspear and cor over scales uses simultaneously fit spear-men
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(indglobseg_motSexC,aes(Age,indglobseg_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global Segreg at Scale", i+1)))
  
  # relevant df
  scaledf<-cbind(indglobseg$Age,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  print(ggplot(groglobseg,aes(Age,groglobseg[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Gro Global Segreg at Scale", i+1)))
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - Individ. Partitions")
groagecor<-correlations_over_scales(gro_segcors,"Global Segregation Age Correlation - Group Partitions")
ggarrange(indagecor,groagecor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_dark(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales")
```

```{r}
### get global seg cors FOR EF
# EF
subjbehav<-read.csv("/cbica/projects/pinesParcels/data/n713_Behavior_20181219.csv")
ef<-data.frame(subjbehav$F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
colnames(ef)<-c('F1_Exec_Comp_Cog_Accuracy','bblid')
# merge in
masteref<-merge(masterdf,ef,by='bblid')
### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Sex,masteref$Motion,masteref[,2:30])
groglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Sex,masteref$Motion,masteref[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "EF","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "EF","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30

#### repeated ggpplot uses residuals, NOT SIMULTANEOUSLY FITTED EF COEFFICIENT AT THE MOMENT ### 
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  
  # relevant df
  scaledf<-cbind(indglobseg$EF,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){

  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indEFcor<-correlations_over_scales(ind_segcors,"Global Segregation EF Correlation - Individ. Partitions")
groEFcor<-correlations_over_scales(gro_segcors,"Global Segregation EF Correlation - Group Partitions")
ggarrange(indEFcor,groEFcor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-EF Correlation')+
    theme_dark(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and EF Correlation Over Scales")

```

```{r}
### get global seg -motion cors
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30


# throw age in again (reprise)
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))


for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  linmod=lm(indglobseg[,i+4]~Age+Sex,data=indglobseg)
  motcor=(cor.test(linmod$residuals,indglobseg$Motion))$estimate
  ind_segcors[i,2]<-motcor
}
## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  linmod=lm(groglobseg[,i+4]~Age+Sex,data=groglobseg)
  motcor=(cor.test(linmod$residuals,groglobseg$Motion))$estimate
  gro_segcors[i,2]<-motcor
}

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Motion Correlation')+
    theme_dark(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Motion Correlation Over Scales")
```


```{r}

# indicators of processing stream
ind='ind'
gro='gro'
###bts='bts'
###
#### indicators of fc feature type
bwi='_bw_FC_'
wini='_win_FC_'
nsegi='_seg_scale'
###gsegi='_globseg_scale'
###
#### indices of said indicators
indiv=grep(ind,colnames(masterdf))
group=grep(gro,colnames(masterdf))
###basists=grep(bts,colnames(df))
bwcol=grep(bwi,colnames(masterdf))
wincols=grep(wini,colnames(masterdf))
nsegcols=grep(nsegi,colnames(masterdf))
###gsegcols=grep(gsegi,colnames(df))
###
# Make motion-regressed version of everything



###segdf<-merge(gseg,df,by="scanid")
###
###seg_cors<-matrix(0,length(community_vec),2)
###seg_cors[,1]<-community_vec
###
###for (i in 1:length(community_vec)){
###  # i+1 because first column is scanid
###  seg_cors[i,2]<-cor.test(segdf[,i+1],segdf$Age)$estimate
###}
###
###correlations_over_scalesplot(correlations=seg_cors,title="Segregation-Age correlations over Scales")

# multi-scale patterning
# shape analyses

### 29 scales, 2 coordinates (x,y), and 693 subjs
globalseg<-array(0,dim=c(29,2,693))

# for each subject, fill in x and y coords. (x is constant, is scale)
for (i in 1:693){
  # 2-30 as x-axis (scales of obs.)
  globalseg[,1,i]<-seq(2,30)
  # y values as error/cost
  # seems more matlabby than characteristic of R that I have to as.x(as.x(df)) for it to work, but here we are
  globalseg[,2,i]<-as.array(as.matrix(indglobseg[i,5:33]))
  
  # scale SDs to be equiv in x and y dimensions (to enforce principled shape)
  #sd1<-(sd(globalseg[,1,i]))
  #sd2<-(sd(globalseg[,2,i]))
  #globalseg[,1,i]<- globalseg[,1,i] * sd2
  #globalseg[,2,i]<- globalseg[,2,i] * sd1
  
}

seg_procrust<-procGPA(globalseg)

shapepca(seg_procrust, pcno=1, type = "v", mag=16)

# get individ. level pc scores into df
indglobseg$pc1<-seg_procrust$scores[,1]

# find dif b/w scale 2 and 30 for simpler description of shape pc
indglobseg$dif<-indglobseg$`2` - indglobseg$`30`
plot(indglobseg$Age,indglobseg$dif)
## plot demonstrative subjs (highest and lowest PC loading)

### note, shape is captured by dif b/w seg at scale 2 and 30
```

```{r}
### analyze relation of transmodality to segregation over scales
### Get in Consensus-reference atlas correspondence
rac<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_yCorrespondence_overscales.csv',stringsAsFactors = F)
scalesvec<-as.numeric(rac[2,])
domnetvec<-as.factor(rac[3,])
netpropvec<-as.numeric(rac[4,])

#### read in transmodality
tm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_transmodality_overscales.csv',stringsAsFactors = F)
colnames(tm)<-tm[1,]
# aaaand remove it
tm<-tm[-c(1),]
tmvec<-as.numeric(tm)

# distribution of transmodality across networks across scales (derived from group consensus)
hist(tmvec,12,xlab="Transmodality",ylab="Count",ylim=c(0,70), main=NULL,col="grey")

# use median transmodality value to split relatively bimodal distribution
medtrans<-median(tmvec)
# equivalent vector to be overwritten with binary classification of transmodality
tmclass<-tmvec
for (i in 1:length(tmclass)){
  if (tmvec[i]<= medtrans){
    tmclass[i]='unimodal'
  }else{
    tmclass[i]='transmodal'
  }
}

############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(individ_scalebywin_df)


########## 7/2/20 - changed to partial correlations to account for sex and motion for each network at each scale

#### Commented out confidence intervals for now, not a feature of the pcor package utilized
# will needs these functions throughout
###corconfinfvecupper<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[1])
###}
###corconfinfveclower<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[2])
###}

corEstVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}

# Notice this references master E f, which has 5 fewer subjects
corEstVec_EF<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$EF),as.numeric(masteref$Sex),masteref$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}


###confvecupper<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corEstVec))
###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)
confvecdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###in_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))


# plot it
Win_age_tm<-ggplot(confvecdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale<-ggplot(confvecdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4)+labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = "AgeWinCor", color="Topological \nScale")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ scale_colour_gradient(low="#55185D", high="#ECB602")
```

```{r}
############ analyze contribution of segregation in network connectivities' age couplings by scale and transmodality #############

# pull out scale x network segregation for individualized maps
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
indiv_scalebynet_df<-masterdf[,indiv_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)

###confvecupper<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corEstVec))

###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))

Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5)

# without proportion
Segreg_age_tm_noprop<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec)) + geom_line(size=1,alpha=.5) + scale_color_manual(name="Predominant \nOverlapping \nYeo7 Network",values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst),alpha=.5) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5) +theme(legend.text=element_text(size=20))

Segreg_age_scale<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=scalesvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = "AgeSegregCor", color="Topological \nScale")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")

Segreg_age_scale_x<-ggplot(Seg_plotdf,aes(scalesvec,corVecEst,color=tmvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = '# of Communities', y = 'Segregation-Age Correlation', color="Transmodality")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")



ggarrange(Segreg_age_tm,Segreg_age_scale,Win_age_tm,Win_age_scale)


### adding in number of patches dimension next
```

```{r}
# Spatial dispersement of network
LHpi<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/numPatches_LH_allscales.csv')
RHpi<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/numPatches_RH_allscales.csv')

Seg_CIplotdf$LH_patchnum<-LHpi$patchnum_over_scalesL
Seg_CIplotdf$RH_patchnum<-RHpi$patchnum_over_scalesR
Seg_CIplotdf$Tot_patchnum<-Seg_CIplotdf$LH_patchnum+Seg_CIplotdf$RH_patchnum

ggplot(Seg_CIplotdf[indofint,],aes(Tot_patchnum,corVecEst,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_point(size=4,aes(Tot_patchnum,corVecEst))+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Total Number of Patches") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Networks')+ ylim(-.5,.5)

ggplot(Seg_CIplotdf[indofint,],aes(tmvec,Tot_patchnum,color=domnetvec,alpha=netpropvec^2,group=V7))+ geom_point(size=4,aes(tmvec,Tot_patchnum)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("Total Patch number") +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Networks')

ggplot(Seg_CIplotdf[indofint,],aes(tmvec,Tot_patchnum,color=scalesvec,group=V7))+ geom_point(size=4,aes(tmvec,Tot_patchnum)) +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Networks')


ggplot(Seg_CIplotdf[indofint,],aes(tmvec,Tot_patchnum))+ geom_pointdensity(size=4, adjust = 3)+ xlab("Transmodality") + ylab("Total Patch number")

ggplot(Seg_CIplotdf[indofint,],aes(corVecEst,Tot_patchnum))+ geom_pointdensity(size=4)+ xlab("Transmodality") + ylab("Total Patch number")
```

```{r}

### BY THE POWER OF OUR INDICES COMBINED!
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]
# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# empty array to populate with b/w connectivity age cors (b/w to unimodal, b/w to transmodal, b/w to aggregate, and K and N and Modality just to confirm we are matching)
bwAgeCorVecs<-matrix(0,464,6)

# loop over connectivities to unimodal then to transmodal
modalloopvar=c('unimodal','transmodal')
for (i in 1:2){
  print(modalloopvar[i])
  # get "the other"
  modalloopvar_other=modalloopvar[modalloopvar!=(modalloopvar[i])]
  # extract which of 1:464 network mappings match the modalitity of this loop
  modalindices=which(tmclass %in% modalloopvar[i])
  # loop over each scale
    for (K in 2:30){
    # Make index of where values from this K should go
      K_start=((K-1)*(K))/2
      K_end=(((K-1)*(K))/2)+K-1
      Kind<-K_start:K_end
      bwAgeCorVecs[Kind,4]=K
    
    # index which values are at this scale
    scaleStr=paste('scale',K,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
    # extract within and between colnames at this scale for within->b/w binarized transmodality mapping
    wincolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),wincolnames)
    wincolnames_thisScale=wincolnames[wincolnames_thisScale_inds]
    bwcolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),bwcolnames)
    bwcolnames_thisScale=bwcolnames[bwcolnames_thisScale_inds]
    
  # one weird trick to get binarized transmodality class vector for same scale (Doctors hate him!)
    # tm naming aligns with wincon naming
    tmclasses_thisScale<-tmclass[wincolnames_thisScale_inds]
    # extract the network number of each network at this scale in same order as tmclasses_thisScale
    wincolNamesSplit<-strsplit(wincolnames_thisScale,"_net")
    wincolNames_net<-sapply(wincolNamesSplit, "[[" , 2)
    # mini matching vectors with network label at this scale in one col and transmodality binarization in the other
    tmMatchingVecs<-cbind(wincolNames_net,tmclasses_thisScale)
    # remove scale number from strings so we're not picking up on those
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    bwnetnames_thisScale<-wincolNames_net<-sapply(bwcolnames_thisScale_split, "[[" , 2)
    # add another fucking set of underscores to all of these colnames so 1's dont pick up 10s
    bwnetnames_thisScale_extended<-paste('ind_bw_FC_scale',K,'_nets_',bwnetnames_thisScale,'_',sep='')
    # extra goddamn undercores have to go here and be removed later
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    # to be matched in all-networks-at-this-scale loop
    # now as we descend into the third circle of for-loop hell, we find the guy from man vs.food being eaten alive by cerberus
    for (N in 1:K){
      # generate index for where values for this network at this scale should reside
      # start from K index
      Nind<-Kind[N]
      bwAgeCorVecs[Nind,5]=N
      # get index for this N in terms of masterdf (collapse | to match multiple patterns)
      Ncolname<-grep(as.character(paste('_',N,'_',sep='')),bwnetnames_thisScale_extended,value=T)
      # need to add "_" before and after each number so I can select for '_N_' and not pick up teens digits with 1, 20s with 3, 15 and 25 with 5, etc.
      # determine if this network is transmodal or unimodal
      NModality<-tmMatchingVecs[,2][[N]]
      ########bwAgeCorVecs[Nind,6]<-NModality
      NotNModality<-modalloopvar[modalloopvar!=NModality]
      matchvec<-grep(NModality,tmclasses_thisScale)
      # remove self
      matchvec<-matchvec[matchvec!=N]
      # build index of matching modalities to reference masterdf (collapse | to match multiple patterns)
      matchTruncColName<-grep(as.character(paste('_',matchvec,'_',sep='',collapse="|")),Ncolname,value=T)
      # remove first and last characters now that we are specific
      #matchTruncColName<-sub('.$','',matchTruncColName)
      #matchTruncColName<-sub('.','',matchTruncColName)
      # deal with weird thing where empty space was being grepped because of its aspecificity at coarse scales
      if(length(matchTruncColName)==0){
        matchTruncColName[1]='CANTSEEME'
      }
      match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(matchTruncColName,collapse="|")),bwnetnames_thisScale_extended)
      match_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      
      # deal with weird thing where empty space was being grepped because of its aspecificity
      if(length(match_NetN_scaleK_bw_indivi_cols_names)==0){
        match_NetN_scaleK_bw_indivi_cols_names[1]='CANTSEEME'
      }
      #################
      #### NEED TO ADD UNDERSCORE TO AFTERPORTION SO IT DOESNT PICK UP 1_20 when looking for 1_2 #########
      ##########
      #bwcolnames_thisScale<-paste(bwcolnames_thisScale,'_',sep='')
      #match_NetN_scaleK_bw_indivi_cols_names<-paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='')
      
      # added a faux '_' to end of column to col names can more selectively match numbers (not picking up on 20 when looking for 2, 2_ and 20_ more distinct)
      match_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
    
      ###############
      ######## find opposite modality in this scale ################
      ###############
      
      oppositevec<-grep(NotNModality,tmclasses_thisScale)
      
      # build index of NON-matching modalities to reference masterdf (collapse | to match multiple patterns)
      unmatchTruncColName<-grep(as.character(paste('_',oppositevec,'_',sep='',collapse="|")),Ncolname,value=T)
      # search for string in limited bwcolnames at this scale so as not to invite other scales into this grep party
      # remove first and last characters now that we are specific
      #unmatchTruncColName<-sub('.$','',unmatchTruncColName)
      #unmatchTruncColName<-sub('.','',unmatchTruncColName)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-grep(as.character(paste(unmatchTruncColName,collapse="|")),bwnetnames_thisScale_extended,value=T)
      
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,collapse="|")),bwnetnames_thisScale_extended)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      unmatch_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
      
      
      # doublecheck that they are mutually exclusive (+1 because self-reference gets removed)
    #  if(length(tmclasses_thisScale)!=length(matchvec)+length(oppositevec)+1){
   #     print('You done goofed, internet police are on their way')
     # }
      if(length(tmclasses_thisScale)!=length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1){
        print('Names dont add up chief')
        paste('match numbas', length(match_NetN_scaleK_bw_indivi_cols_ind), length(match_NetN_scaleK_bw_indivi_cols_names))
        paste('unmatch numbas', length(unmatch_NetN_scaleK_bw_indivi_cols_ind), length(unmatch_NetN_scaleK_bw_indivi_cols_names))
        stopifnot(length(tmclasses_thisScale)==length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1)
      }
      unmatch_NetN_scaleK_bw_indivi_cols_ind
      # Reset these to NULL for each loop over N for equivalent looping
      
      
      # if it matches the modality being aggregated in the grandparent loop, we wish to only assay its connections to same-modality networks
      if (NModality==modalloopvar[i] && length(matchvec>0)){
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_same<-rowMeans(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind,drop=F])
        # get mean agecor with matching networks
        avg_bw_agecor<-corEstVec(avg_bw_same)
      } else if (NModality!=modalloopvar[i]) {  
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_dif<-rowMeans(masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
        # get mean agecor with non-matching networks
        avg_bw_agecor<-corEstVec(avg_bw_dif)
      } else if (NModality==modalloopvar[i] && (exists("matchvec[1]"))=='FALSE') {
        # easily findable index for cells which should not be filled (i.e., there is no "to unimodal connectivity" for the only unimodal networks at any scale)
        avg_bw_agecor<-999
      }
      # if it does not match the modality of the grandparent loop, we wish go assay its connections to opposite-modality networks
      bwAgeCorVecs[Nind,i]=avg_bw_agecor
    # get average bw network connectivty age correlation for this network at this scale
      both=cbind(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind],masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
      avg_bw=rowMeans(both)
      avg_bw_coarse_agecor<-corEstVec(avg_bw)
      bwAgeCorVecs[Nind,3]=unlist(avg_bw_coarse_agecor)
    }
    # Print out ratio of transmodal to unimodal at this scale
    unilength=length(tmclasses_thisScale[tmclasses_thisScale=='unimodal'])
    translength=length(tmclasses_thisScale[tmclasses_thisScale=='transmodal'])
    print(paste('uni to trans ratio:', unilength/translength))
  }
  
}
bwAgeCorVecs<-data.frame(bwAgeCorVecs)
```

```{r}


# analyze between network connectivities' couplings with age by transmodality
colnames(bwAgeCorVecs)<-c('bw_to_unimodal','bw_to_transmodal','avg_bw','K','N')
############ analyze contribution of avg b/w network connectivities' age couplings by scale and transmodality #############

# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)
bwdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)


# avg b/w
avgbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w con avg and Age over All Networks') + ylim(-.5,.5)

avgbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# b/w to unimodal
unibw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWUCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w unimodal con and Age over All Networks')+ ylim(-.5,.5)

unibw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWUCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# b/w to transmodal
transbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWTCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w transmodal con and Age over All Networks')+ ylim(-.5,.5)

transbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWTCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

ggarrange(avgbw_age_tm,unibw_age_tm,transbw_age_tm,avgbw_age_scale,unibw_age_scale,transbw_age_scale)
```

```{r}
#### now make it for group template-measured FC vaues, starting with within and segreg
############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
gro_wincols_ind<-intersect(wincols,group)
group_scalebynet_df<-masterdf[,gro_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(group_scalebynet_df)


confvecupper<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfvecupper))
confveclower<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,gro_wincols_ind],corEstVec))
confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
confveclower_d[,7]<-CIgroupingInd
confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
colnames(confveclower_d)[2]<-"CIbounds"
colnames(confvecupper_d)[2]<-"CIbounds"
gro_win_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))
# range of interest until we work out K=2 and K=3
indofint<-6:464
indofint<-append(indofint,(470:928))

# plot it
Win_age_tm_gro<-ggplot(gro_win_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_line(size=1) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Connectivity and Age over All Networks (GRO)')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale_gro<-ggplot(gro_win_CIplotdf[indofint,],aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# pull out scale x network segregation for individualized maps
gro_nsegcols_ind<-intersect(nsegcols,group)
gro_scalebynet_df<-masterdf[,gro_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(gro_scalebynet_df)

confvecupper<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corconfinfvecupper))
confveclower<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corEstVec))

confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
confveclower_d[,7]<-CIgroupingInd
confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
colnames(confveclower_d)[2]<-"CIbounds"
colnames(confvecupper_d)[2]<-"CIbounds"
gro_seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))
# range of interest until we work out K=2 and K=3
indofint<-6:464
indofint<-append(indofint,(470:928))


Segreg_age_tm_gro<-ggplot(gro_seg_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_line(size=1) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Segregation and Age over All Networks (GRO)')+ ylim(-.5,.5)

Segreg_age_scale_gro<-ggplot(gro_seg_CIplotdf[indofint,],aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)


ggarrange(Segreg_age_tm_gro,Segreg_age_scale_gro,Win_age_tm_gro,Win_age_scale_gro)
```

```{r}
# get the gang together
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
gro_nsegcols_ind<-intersect(nsegcols,group)

# functions to write out the corvec estimates for matlab-based viz
pcorEstVecNsave<-function(x,K,vecIn){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

pcorEstVec_EFNsave<-function(x,K,vecIn){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$F1_Exec_Comp_Cog_Accuracy),as.numeric(masteref$Sex),masteref$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

# get residuals (constant over loops)
# loop over scales
for (i in 2:30){
  print(i)
  keyphrase<-paste('seg_scale',as.character(i),'_net',sep='')
  scaleind=grep(keyphrase,colnames(masterdf))
  # just individualized for now
  # reads in vector of segreg vals aligned with age vals and scale 
  vec_age<-NULL
  vec_age<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],pcorEstVecNsave,K=i,vecIn=vec_age)
  vecfp_Age<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_Age.csv',sep='')
  write.table(as.numeric(vec_age),vecfp_Age,row.names = F,col.names = F,sep = ',')
  vec_ef<-NULL
  vec_ef<-lapply(masteref[,intersect(indiv_nsegcols_ind,scaleind)],pcorEstVec_EFNsave,K=i,vecIn=vec_ef)
  vecfp_EF<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_EF.csv',sep='')
  write.table(as.numeric(vec_ef),vecfp_EF,row.names = F,col.names = F,sep = ',')
}

# Write em out as matlab readable vectors (K: N1est N2est ... Nnest)

```

```{r}
# load gradstats
grad_sum_df<-read.csv('/cbica/projects/pinesParcels/lambdas_pg1.csv',header=F)
age<-data.frame(demo$ageAtScan1,demo$bblid)
colnames(grad_sum_df)<-c("bblid","grad1lambda")
colnames(age)<-c("age","bblid")
grad_sum_df$bblid<-as.integer(grad_sum_df$bblid)
merged_df<-merge(grad_sum_df,age,by="bblid")

# load grad-dm-cors
graddmcor<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/SpatialCorIndK3DMPG1.csv',header=F);
# temp exlcusion of misreads
tmpexcl<-graddmcor[graddmcor[,2]<0.35,1]
#100869 106154 107929 109577 110166 110354 118807 120922 121017 122352 122669 127305 130121 130332 131747  80537  83207
#86690  88190  88859  89063  89534  96201  98879
tempexclind<-which(tmpexcl %in% merged_df$bblid)
merged_df_tmpexcl=merged_df[-c(tempexclind),]
colnames(merged_df_tmpexcl)[1]<-"Subjects"
masterdf$Subjects<-as.factor(masterdf$Subjects)
testfordmseg<-merge(merged_df_tmpexcl, masterdf, by="Subjects")
```

```{r}
# long df
long_precursor<-data.frame(masterdf$bblid,masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,indiv_nsegcols_ind])
melt_long<-melt(long_precursor,id=c(1,2,3,4))
tmvecRepped<-rep(tmvec,each=693)
melt_long$transmodality<-tmvecRepped
saveRDS(melt_long,file = '~/Desktop/Long_bblidAgeSexMotionSegreg.rds')
```
