---
title: "Multiscale_statsnfigs"
author: "Adam"
date: "6/7/2020"
output: html_document
---

```{r}
source('~/cbica/projects/pinesParcels/multiscale/scripts/analyses/')
library(shapes)
library(ggplot2)
library(reshape2)
library(dplyr)
library(ggpubr)
library(vroom)
library(data.table)
library(mgcv)
library(ggpointdensity)
library(ppcor)
library(viridis)
# load in demo
demo<-read.csv('/cbica/projects/pinesParcels/data/pnc_demo.csv')
ageSex<-data.frame(demo$ageAtScan1,as.factor(demo$sex),demo$scanid,demo$bblid)
subjects<-read.csv('/cbica/projects/pinesParcels/data/participants.txt',header = F)

###M MOTION METRIC M###
Rest_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_RestQAData_20170714.csv")
NBack_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_NBACKQAData_20181001.csv")
Idemo_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_idemo_FinalQA_092817.csv")

motmerge<-merge(Rest_Motion_Data,NBack_Motion_Data,by='bblid')
motmerge<-merge(motmerge,Idemo_Motion_Data,by='bblid')
motmerge$Motion <- (motmerge$restRelMeanRMSMotion + motmerge$nbackRelMeanRMSMotion + motmerge$idemoRelMeanRMSMotion)/3;
motiondf<-data.frame(motmerge$bblid,motmerge$Motion)
colnames(motiondf)<-c('bblid','Motion')
###M                 M###

colnames(subjects)<-c("scanid")
colnames(ageSex)<-c("Age","Sex","scanid","bblid")
df<-merge(subjects,ageSex,by="scanid")
df<-merge(df,motiondf,by='bblid')
# community solutions guaged in this iteration
community_vec<-seq(2,30)

# load in error over scales
numiter=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_n',header = F)
iter_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_error',header = F)
recon_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/recon_error',header=F)

# bblids got rounded in matlab csvwrite in this iteration, plug ids directly in
bblids<-read.delim('/cbica/projects/pinesParcels/data/bblids.txt',header=F)
# yes, I double checked that they matched up
numiter$V1<-bblids[,1]
iter_err$V1<-bblids[,1]
recon_err$V1<-bblids[,1]

# calculate difference
dfdif=iter_err
dfdif[,2:30]=iter_err[,2:30]-recon_err[2:30]

# get ages and motion in there

colnames(iter_err)[1]<-"bblid"
colnames(numiter)[1]<-"bblid"
colnames(recon_err)[1]<-"bblid"
colnames(dfdif)[1]<-"bblid"

df_tc<-merge(df,iter_err,by="bblid")
df_ni<-merge(df,numiter,by="bblid")
df_rc<-merge(df,recon_err,by="bblid")
df_dif<-merge(df,dfdif,by="bblid")

mdata<-melt(df_tc,id=c(1,2,3,4,5))
mdatani<-melt(df_ni,id=c(1,2,3,4,5))
mdatarc<-melt(df_rc,id=c(1,2,3,4,5))
mdatadif<-melt(df_dif,id=c(1,2,3,4,5))

tc<-ggplot(data=mdata[1:5000,],aes(x=variable,y=value,group=bblid,color=Age)) +geom_step(alpha = 0.15,size=10)+ scale_color_gradient2(low = "green", mid = 'red', high = "green") + theme_minimal()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Non-recon error over scales")


ggarrange(tc,ni,dif,rc)

# plot average recon error over scales
mreconerr<-(colMeans(recon_err)[2:30])
mcrecnerrdf<-data.frame(mreconerr,community_vec)
ggplot(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec))+geom_line(col='black',size=2)+theme_minimal(base_size = 28)+ggtitle("Reconstruction Error Over Scales")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Recon. Error")

# Motion and Sex Replacing Age (characterize indep. relations before controlling for them)


# libraries just for this friggin raincloud
library(readr)
library(tidyverse)
library(ggplot2)
source("https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R")
library(plyr)
library(RColorBrewer)
library(reshape2)
raincloud_theme <- theme(
  text = element_text(size = 10),
  axis.title.x = element_text(size = 16),
  axis.title.y = element_text(size = 16),
  axis.text = element_text(size = 14),
  axis.text.x = element_text(angle = 45, vjust = 0.5),
  legend.title = element_text(size = 16),
  legend.text = element_text(size = 16),
  legend.position = "right",
  plot.title = element_text(lineheight = .8, face = "bold", size = 16),
  panel.border = element_blank(),
  panel.grid.minor = element_blank(),
  panel.grid.major = element_blank(),
  axis.line.x = element_line(colour = "black", size = 0.5, linetype = "solid"),
  axis.line.y = element_line(colour = "black", size = 0.5, linetype = "solid"))

ggplot(data = df, aes(y = Motion, x = Sex, fill = Sex)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), alpha = .8) +
    geom_point(aes(y = Motion, color = Sex), position = position_jitter(width = .15), size = .5, alpha = 0.8) +
    geom_boxplot(width = .1, outlier.shape = NA, alpha = 0.5) +
    coord_flip() +
    theme_bw() +
    raincloud_theme






############# Equiv Plots for these fine variables
tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal()+labs(title="Non-recon error over scales")

ggarrange(tc,ni,dif,rc)

tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2) + theme_minimal()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2)+ theme_minimal()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2)+ theme_minimal()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.07,size=2) + theme_minimal()+labs(title="Non-recon error over scales")

ggarrange(tc,ni,dif,rc)

# plot variability over scales with recon error over scales
varoverscales=read.csv('/cbica/projects/pinesParcels/results/aggregated_data/Variability_overScales.csv')
colnames(varoverscales)=c('SoftVar','HardVar')
varoverscales$community_vec<-community_vec

# make a vector for shape in these plots
scalevec<-rep(0,times=29)
changevec<-scalevec
for (i in 2:29){
  changevec[i]<-mcrecnerrdf$mreconerr[i]-mcrecnerrdf$mreconerr[i-1]
}


shapedvec<-c(2,6,12,25)
scalevec[shapedvec]<-1

mcrecnerrdf$shape<-scalevec
mcrecnerrdf$change<-changevec

# select vector for chosen visualized scales (-1 because scales start at 2)
selectvec<-rep(0,29)
selectvec[3]<-1
selectvec[6]<-1
selectvec[12]<-1
selectvec[19]<-1
mcrecnerrdf$select<-selectvec
# make vector for scales of interest

avgrecon<-ggplot(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec,color=abs(change)))+geom_step(size=2)+theme_minimal(base_size = 28)+ggtitle("Reconstruction Error Over Scales")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Recon. Error")+scale_color_continuous(name='Decrease\nfrom prev.') + geom_point(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec,size=select*5))+guides(size=F)+theme(legend.position="left")

avgSPvar<-ggplot(data=varoverscales,aes(y=SoftVar,x=community_vec))+geom_step(col='black',size=2)+theme_minimal(base_size = 28)+ggtitle("Loading Variability (MAD)")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Avg. MAD")
avgHPvar<-ggplot(data=varoverscales,aes(y=HardVar,x=community_vec))+geom_step(col='black',size=2)+theme_minimal(base_size = 28)+ggtitle("Label Variability (Entropy)")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Avg. Entropy")

ggarrange(avgrecon,avgSPvar,nrow = 1)
```

```{r}
# load in FC features (takes about 3 minutes) - original file - not loaded in anymore because it tooks forever and new version is just rounded digits to a few decimal places

#fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')

#oldfc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_old.csv')
####### indicates it was part of (passed) check if new fc selectively replaced K=3 - can reactivate for further confirm
#fc<-fread('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')
# set colnames to matlab-printed colnames
#colnames(fc)<-unlist(fc[1,])
#colnames(oldfc)<-oldfc[1,]
# aaaand remove it
#fc<-fc[-c(1),]
#oldfc<-oldfc[-c(1),]

#fc<-data.frame(fc)

# round ridiculous number of decimal points
#fc[] <- lapply(fc, function(x) {
#  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
#})
#oldfc[] <- lapply(oldfc, function(x) {
#  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
#})

# trying to re-write the rounded version again
###write.csv(fc,'/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')

### it's rounded now bb
fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')

# take out row number row
fc<-fc[-c(1)]

# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

# AGE
masterdf<-merge(fc,df,by='bblid')


### isolate global segreg columns
gsegcols<-grep("globseg",colnames(masterdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))

# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(size=2,alpha = 0.2)+ scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ scale_colour_gradient2(low='#1B75BB',mid='orchid4',high='#FAAF40',midpoint = 15) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") +ylab("Global Segregation")
                                                                                                                                                                                                                                                                                                                          
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales pl
#plots, colored by Motion ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales plots, colored by Sex ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_step(alpha = 0.15,size=10)+ theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.1,size=2)+ theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)


# formal t.test for gro seg vs ind seg
indsegvec<-as.vector(unlist(indglobseg[,3:31]))
grosegvec<-as.vector(unlist(groglobseg[,3:31]))
t.test(indsegvec,grosegvec,paired=T)



########### Global seg after regressing out motion
# regress effect of age out on sex and motion
indglobseg_motSexC<-indglobseg
groglobseg_motSexC<-groglobseg

# Z-scored for check of my stats knowledge
indglobseg_Zs<-indglobseg

indglobseg_Zs$Age<-(indglobseg$Age-mean(indglobseg$Age))/sd(indglobseg$Age)
indglobseg_Zs$Motion<-(indglobseg$Motion-mean(indglobseg$Motion))/sd(indglobseg$Motion)

```

```{r}
# break up the big chunks

for (i in 5:33){
  CLM<-lm(indglobseg[,i]~Motion+Sex,data=indglobseg)
  indglobseg_motSexC[,i]<-CLM$residuals
  GCLM<-lm(groglobseg[,i]~Motion+Sex,data=groglobseg)
  groglobseg_motSexC[,i]<-GCLM$residuals
  # add in mean for more interpretable values
  indglobseg_motSexC[,i]<-indglobseg_motSexC[,i]+mean(indglobseg[,i])
  groglobseg_motSexC[,i]<-groglobseg_motSexC[,i]+mean(groglobseg[,i])
  
  meanval<-mean(indglobseg[,i])
  sdofvals<-sd(indglobseg[,i])
  Zvals<-(indglobseg[,i]-meanval)/sdofvals
  indglobseg_Zs[,i]<-Zvals
  
  plotdf<-data.frame((indglobseg_motSexC[,i]+mean(indglobseg[,i])),(indglobseg$Age))
  colnames(plotdf)=c('Segregation','Age')
print(ggplot(data=plotdf,aes(x=Age,y=Segregation)) +geom_point() + theme_minimal(base_size = 28)+labs(title=paste((i-3))) + scale_x_continuous(name ="Age",  breaks=seq(2, 30, 4))+ylab("Global Segregation"))
}


# mean seg and sd over scales plot
SegMeans<-NULL
SegSds<-NULL
for (i in 5:33){ # 2 because first col is name
  SegMeans[i-4]<-mean(indglobseg_motSexC[,i])
  SegSds[i-4]<-sd(indglobseg_motSexC[,i])
}

forSegplot<-data.frame(cbind(SegMeans,community_vec))
forSegplus<-data.frame(cbind(SegMeans+SegSds,community_vec))
forSegminus<-data.frame(cbind(SegMeans-SegSds,community_vec))

ggplot(forSegplot,aes(community_vec,SegMeans)) + geom_step(col="#262228", size=2) + geom_step(data=forSegplus,aes(community_vec,V1), color="#0375B4", size = 2) + geom_step(data=forSegminus,aes(community_vec,V1), color="#0375B4", size = 2)+theme_minimal(base_size = 35) +theme(panel.grid.minor = element_blank()) + xlab('# of Communities') +ylab("Global Segregation") +labs(title="Global Segregation - Individ. Partitions")
```

```{r}
mCindglobseg<-melt(indglobseg_motSexC, id=c(1,2,3,4))
mCgroglobseg<-melt(groglobseg_motSexC, id=c(1,2,3,4))



# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mCindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_step(alpha = 0.3,size=10)+ scale_color_viridis(option="D") + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")

groseg<-ggplot(data=mCgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Group Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

### Add rank plot
indglobseg_motSexCRank<-indglobseg_motSexC
for (K in 2:30){
  indglobseg_motSexCRank[,K+3]=rank(indglobseg_motSexC[,K+3])
}
mCindglobsegRank<-melt(indglobseg_motSexCRank, id=c(1,2,3,4))

ggplot(data=mCindglobsegRank,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.2)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation Rank")
```

```{r}

GBw=vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/globalBw_fcfeats.csv')
GWin=vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/globalWin_fcfeats.csv')

colnames(GBw)<-unlist(GBw[1,])
colnames(GWin)<-unlist(GWin[1,])

# identical parsing as above

GBw<-data.frame(GBw)
GWin<-data.frame(GWin)

# round ridiculous number of decimal points
GBw[] <- lapply(GBw, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})
GWin[] <- lapply(GWin, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})

# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

# set subjects column to bblid
colnames(GWin)[1]<-'bblid'
colnames(GBw)[1]<-'bblid'
GWindf<-merge(GWin,df,by='bblid')
GBwdf<-merge(GBw,df,by='bblid')

### isolate global columns
gWincols<-grep("globWin",colnames(GWindf))
gBwcols<-grep("globBw",colnames(GBwdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobWin<-cbind(GWindf$bblid,GWindf$Age/12,GWindf$Sex,GWindf$Motion,GWindf[,2:30])
indglobBw<-cbind(GBwdf$bblid,GBwdf$Age/12,GBwdf$Sex,GBwdf$Motion,GBwdf[,2:30])

# set colnames
colnames(indglobWin)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobBw)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobWin)[5:33]<-as.character(2:30)
colnames(indglobBw)[5:33]<-as.character(2:30)
indglobWin$Sex<-as.factor(indglobseg$Sex)
indglobBw$Sex<-as.factor(groglobseg$Sex)

# regress effect of age out on sex and motion
indglobWin_motSexC<-indglobWin
indglobBw_motSexC<-indglobBw

for (i in 5:33){
  WCLM<-lm(indglobWin[,i]~Motion+Sex,data=indglobWin)
  indglobWin_motSexC[,i]<-WCLM$residuals
  BWCLM<-lm(indglobBw_motSexC[,i]~Motion+Sex,data=indglobBw)
  indglobBw_motSexC[,i]<-BWCLM$residuals
  # add in mean for more interpretable values
  indglobWin_motSexC[,i]<-indglobWin_motSexC[,i]+mean(indglobWin[,i])
  indglobBw_motSexC[,i]<-indglobBw_motSexC[,i]+mean(indglobBw[,i])
}


# melt it
mindglobwin<-melt(indglobWin_motSexC, id=c(1,2,3,4))
mgroglobbw<-melt(indglobBw_motSexC, id=c(1,2,3,4))


WinAll<-ggplot(data=mindglobwin,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Within - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Within")

BwAll<-ggplot(data=mgroglobbw,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Bw - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Between")

### Now with motion + sex control
# 29 for scales studied
ind_GWincors<-matrix(0,29,2)
ind_GWincors[,1]<-2:30
ind_GBwcors<-matrix(0,29,2)
ind_GBwcors[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(indglobWin_motSexC,aes(Age,indglobWin_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global Win at Scale", i+1)))
    print(ggplot(indglobBw_motSexC,aes(Age,indglobBw_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global BW at Scale", i+1)))
  
# relevant df
  Winscaledf<-cbind(indglobWin$Age,indglobWin$Sex,indglobWin$Motion,indglobWin[,i+4])
  Bwscaledf<-cbind(indglobBw$Age,indglobBw$Sex,indglobBw$Motion,indglobBw[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(Winscaledf,method='spearman')$estimate
  ind_GWincors[i,2]<-pspear[4]
  pspear=pcor(Bwscaledf,method='spearman')$estimate
  ind_GBwcors[i,2]<-pspear[4]
}


WinCors<-correlations_over_scales(ind_GWincors,"Global WithinCon Age Correlation")

BwCors<-correlations_over_scales(ind_GBwcors,"Global BetweenCon Age Correlation")

ggarrange(WinAll,WinCors,BwAll,BwCors)
```


```{r}
### get global seg cors
### Now with motion + sex control
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30
# make an "all" segcors for plotting a thousand lines down or so
ind_segcorsa<-ind_segcors
# 7/11 - testing across age ranges for that dependence
indglobseg_813<-subset(indglobseg,indglobseg$Age<13)
indglobseg_1318<-subset(indglobseg,indglobseg$Age>13 & indglobseg$Age <18)
indglobseg_1823<-subset(groglobseg,groglobseg$Age>18)
groglobseg_813<-subset(groglobseg,groglobseg$Age<13)
groglobseg_1318<-subset(groglobseg,groglobseg$Age>13 & groglobseg$Age <18)
groglobseg_1823<-subset(groglobseg,groglobseg$Age>18)

#### repeated ggpplot uses residuals, but pspear and cor over scales uses simultaneously fit spear-men
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(indglobseg_motSexC,aes(Age,indglobseg_motSexC[,i+4])) + geom_point(size=2,alpha=.3) +theme_minimal(base_size = 30)+ geom_smooth() +ylab(paste("Segreg. at Scale", i+1)))
  
  
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg$Age,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsa[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  print(ggplot(groglobseg,aes(Age,groglobseg[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Gro Global Segreg at Scale", i+1)))
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - Individ. Partitions")
groagecor<-correlations_over_scales(gro_segcors,"Global Segregation Age Correlation - Group Partitions")
ggarrange(indagecor,groagecor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
all<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales")



#### age segment-specific plots
########younguns###########
ind_segcorsy<-matrix(0,29,2)
ind_segcorsy[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_813$Age,indglobseg_813$Sex,indglobseg_813$Motion,indglobseg_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsy[i,2]<-pspear[4]
}

for (i in 1:29){
  scaledf<-cbind(groglobseg_813$Age,groglobseg_813$Sex,groglobseg_813$Motion,groglobseg_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

youngindagecor<-correlations_over_scalesplot_minor(ind_segcors,"Global Segregation Age Correlation - 8-13 Year Olds")

ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
young<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 8-13 Years")

###########mids##############
ind_segcorsm<-matrix(0,29,2)
ind_segcorsm[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_1318$Age,indglobseg_1318$Sex,indglobseg_1318$Motion,indglobseg_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsm[i,2]<-pspear[4]
}
for (i in 1:29){
  scaledf<-cbind(groglobseg_1318$Age,groglobseg_1318$Sex,groglobseg_1318$Motion,groglobseg_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

midindagecor<-correlations_over_scalesplot_minor(ind_segcors,"Global Segregation Age Correlation - 13-18 Year Olds")

ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
mid<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 13-18 Years")


###########geezers##########
ind_segcorsg<-matrix(0,29,2)
ind_segcorsg[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_1823$Age,indglobseg_1823$Sex,indglobseg_1823$Motion,indglobseg_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsg[i,2]<-pspear[4]
}

for (i in 1:29){
  scaledf<-cbind(groglobseg_1823$Age,groglobseg_1823$Sex,groglobseg_1823$Motion,groglobseg_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

oldindagecor<-correlations_over_scalesplot_minor(ind_segcors,"Global Segregation Age Correlation - 18-23 Year Olds")


ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
old<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 18-23 Years")

ageBreakDown<-ggarrange(indagecor,youngindagecor,midindagecor,oldindagecor)
gro_vs_ind<-ggarrange(all,young,mid,old)

```

```{r}
ggarrange(indseg,indagecor,WinAll,WinCors,BwAll,BwCors,ncol = 2,nrow=3)
```

```{r}
### get global seg cors FOR EF
# EF
subjbehav<-read.csv("/cbica/projects/pinesParcels/data/n713_Behavior_20181219.csv")
ef<-data.frame(subjbehav$F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
colnames(ef)<-c('F1_Exec_Comp_Cog_Accuracy','bblid')
# merge in
masteref<-merge(masterdf,ef,by='bblid')
### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Sex,masteref$Motion,masteref[,2:30])
groglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Sex,masteref$Motion,masteref[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "EF","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "EF","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30

#### repeated ggpplot uses residuals, NOT SIMULTANEOUSLY FITTED EF COEFFICIENT AT THE MOMENT ### 
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  
  # relevant df
  scaledf<-cbind(indglobseg$EF,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){

  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indEFcor<-correlations_over_scales(ind_segcors,"Global Segregation EF Correlation - Individ. Partitions")
groEFcor<-correlations_over_scales(gro_segcors,"Global Segregation EF Correlation - Group Partitions")
ggarrange(indEFcor,groEFcor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-EF Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and EF Correlation Over Scales")

```

```{r}
### get global seg -motion cors
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30


# throw age in again (reprise)
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))


for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  linmod=lm(indglobseg[,i+4]~Age+Sex,data=indglobseg)
  motcor=(cor.test(linmod$residuals,indglobseg$Motion))$estimate
  ind_segcors[i,2]<-motcor
}
## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  linmod=lm(groglobseg[,i+4]~Age+Sex,data=groglobseg)
  motcor=(cor.test(linmod$residuals,groglobseg$Motion))$estimate
  gro_segcors[i,2]<-motcor
}

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Motion Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Motion Correlation Over Scales")
```


```{r}

# indicators of processing stream
ind='ind'
gro='gro'
###bts='bts'
###
#### indicators of fc feature type
bwi='_bw_FC_'
wini='_win_FC_'
nsegi='_seg_scale'
###gsegi='_globseg_scale'
###
#### indices of said indicators
indiv=grep(ind,colnames(masterdf))
group=grep(gro,colnames(masterdf))
###basists=grep(bts,colnames(df))
bwcol=grep(bwi,colnames(masterdf))
wincols=grep(wini,colnames(masterdf))
nsegcols=grep(nsegi,colnames(masterdf))
###gsegcols=grep(gsegi,colnames(df))
###
# Make motion-regressed version of everything



###segdf<-merge(gseg,df,by="scanid")
###
###seg_cors<-matrix(0,length(community_vec),2)
###seg_cors[,1]<-community_vec
###
###for (i in 1:length(community_vec)){
###  # i+1 because first column is scanid
###  seg_cors[i,2]<-cor.test(segdf[,i+1],segdf$Age)$estimate
###}
###
###correlations_over_scalesplot(correlations=seg_cors,title="Segregation-Age correlations over Scales")

# multi-scale patterning
# shape analyses

### 29 scales, 2 coordinates (x,y), and 693 subjs
globalseg<-array(0,dim=c(29,2,693))

# for each subject, fill in x and y coords. (x is constant, is scale)
for (i in 1:693){
  # 2-30 as x-axis (scales of obs.)
  globalseg[,1,i]<-seq(2,30)
  # y values as error/cost
  # seems more matlabby than characteristic of R that I have to as.x(as.x(df)) for it to work, but here we are
  globalseg[,2,i]<-as.array(as.matrix(indglobseg[i,5:33]))
  
  # scale SDs to be equiv in x and y dimensions (to enforce principled shape)
  #sd1<-(sd(globalseg[,1,i]))
  #sd2<-(sd(globalseg[,2,i]))
  #globalseg[,1,i]<- globalseg[,1,i] * sd2
  #globalseg[,2,i]<- globalseg[,2,i] * sd1
  
}

seg_procrust<-procGPA(globalseg)

shapepca(seg_procrust, pcno=1, type = "v", mag=16)

# get individ. level pc scores into df
indglobseg$pc1<-seg_procrust$scores[,1]

# find dif b/w scale 2 and 30 for simpler description of shape pc
indglobseg$dif<-indglobseg$`2` - indglobseg$`30`
plot(indglobseg$Age,indglobseg$dif)
## plot demonstrative subjs (highest and lowest PC loading)

### note, shape is captured by dif b/w seg at scale 2 and 30
```

```{r}
### analyze relation of transmodality to segregation over scales
### Get in Consensus-reference atlas correspondence
rac<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_yCorrespondence_overscales.csv',stringsAsFactors = F)
scalesvec<-as.numeric(rac[2,])
domnetvec<-as.factor(rac[3,])
netpropvec<-as.numeric(rac[4,])

# 17 network version
### Get in Consensus-reference atlas correspondence
rac17<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_y17Correspondence_overscales.csv',stringsAsFactors = F)
scalesvec17<-as.numeric(rac17[2,])
domnetvec17<-as.factor(rac17[3,])
netpropvec17<-as.numeric(rac17[4,])


#### read in transmodality
tm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_transmodality_overscales.csv',stringsAsFactors = F)
colnames(tm)<-tm[1,]
# aaaand remove it
tm<-tm[-c(1),]
tmvec<-as.numeric(tm)

# distribution of transmodality across networks across scales (derived from group consensus)
hist(tmvec,12,xlab="Transmodality",ylab="Count",ylim=c(0,70), main=NULL,col="grey")

# use median transmodality value to split relatively bimodal distribution
medtrans<-median(tmvec)
# equivalent vector to be overwritten with binary classification of transmodality
tmclass<-tmvec
for (i in 1:length(tmclass)){
  if (tmvec[i]<= medtrans){
    tmclass[i]='unimodal'
  }else{
    tmclass[i]='transmodal'
  }
}

############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(individ_scalebywin_df)


########## 7/2/20 - changed to partial correlations to account for sex and motion for each network at each scale

#### Commented out confidence intervals for now, not a feature of the pcor package utilized
# will needs these functions throughout
###corconfinfvecupper<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[1])
###}
###corconfinfveclower<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[2])
###}

corEstVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}

# Notice this references master E f, which has 5 fewer subjects
corEstVec_EF<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$EF),as.numeric(masteref$Sex),masteref$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}


###confvecupper<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corEstVec))
###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)
confvecdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###in_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))


# plot it
Win_age_tm<-ggplot(confvecdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale<-ggplot(confvecdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4)+labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = "AgeWinCor", color="Topological \nScale")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ scale_colour_gradient(low="#55185D", high="#ECB602")

#17 network version
confvecdf17<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,corVecEst)
Win_age_tm17<-ggplot(confvecdf17,aes(tmvec,corVecEst,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab("AgeWinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within-Network Con and Age over All Communities')+ ylim(-.5,.5)
```

```{r}
############ analyze contribution of segregation in network connectivities' age couplings by scale and transmodality #############

# pull out scale x network segregation for individualized maps
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
indiv_scalebynet_df<-masterdf[,indiv_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)

###confvecupper<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corEstVec))

###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))

Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5)

# without proportion
Segreg_age_tm_noprop<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec)) + geom_line(size=1,alpha=.5) + scale_color_manual(name="Predominant \nOverlapping \nYeo7 Network",values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst),alpha=.5) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5) +theme(legend.text=element_text(size=20))

Segreg_age_scale<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=scalesvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = "AgeSegregCor", color="Topological \nScale")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")

Segreg_age_scale_x<-ggplot(Seg_plotdf,aes(scalesvec,corVecEst,color=tmvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = '# of Communities', y = 'Segregation-Age Correlation', color="Transmodality")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")



ggarrange(Segreg_age_tm,Segreg_age_scale,Win_age_tm,Win_age_scale)

#17 network version
Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,corVecEst)
Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5)
```

```{r}
# long df
long_precursor<-data.frame(masterdf$bblid,masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,indiv_nsegcols_ind])
melt_long<-melt(long_precursor,id=c(1,2,3,4))
tmvecRepped<-rep(tmvec,each=693)
domnetvecRepped<-rep(domnetvec,each=693)
melt_long$transmodality<-tmvecRepped
melt_long$dominantYeo<-domnetvecRepped
saveRDS(melt_long,file = '~/Desktop/Long_bblidAgeSexMotionSegreg.rds')
```


```{r}
# delineate age trajectories of every net.
library(gratia)
library(dplyr)
library(svglite)
library(cowplot)
library(mgcv)
library(viridis)

covariates=" ~s(Age,k=4)+Sex+Motion"   

minAgeEst<-rep(0,length=length(masterdf[,indiv_nsegcols_ind]))
maxAgeEst<-rep(0,length=length(masterdf[,indiv_nsegcols_ind]))

derivInfo<-array(0,dim=c(464,200))
NetSplines<-array(0,dim=c(464,693))                  



#for i in 464
for (i in 1:length(masterdf[,indiv_nsegcols_ind])){
  x<-colnames(masterdf[,indiv_nsegcols_ind][i])
  form<-as.formula(paste("",x,"", covariates, sep=""))
  igam<-gam(formula = form,data=masterdf)
  derv<-derivatives(igam,term='Age')
  derv<- derv %>%
  mutate(sig = !(0 >lower & 0 < upper))
  derv$sig_deriv = derv$derivative*derv$sig
  if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
  } else {
  minAgeEst[i]<-min(derv$data[derv$sig==T])
  maxAgeEst[i]<-max(derv$data[derv$sig==T])
  # changed to sig deriv only 7/10/20
  derivInfo[i,]=derv$sig_deriv
  forSpline<-predict(igam, data = masterdf, type = "terms")
  # adding mean val because output values are centered
  colOfInt<-unlist(masterdf[,indiv_nsegcols_ind][i])
  NetSplines[i,]<-forSpline[,3]+coef(igam)[1]
  if (mean(colOfInt)<.3){
    print(paste(x,mean(colOfInt)))
  }
  }
  ###cat(sprintf("\nSig change: %1.2f - %1.2f\n",minAgeEst[i],maxAgeEst[i]))
}

# years format
minAgeEst<-minAgeEst/12
maxAgeEst<-maxAgeEst/12

CIgroupingInd<-as.factor(1:464)

#convert to years for more interpretable slope
derivInfo<-derivInfo*12





# get a vector of the agespan split into 200 to match the deriv vals
agerange<-range(masterdf$Age)/12
agerange200<-seq(agerange[1],agerange[2],length.out = 200)

AgeSpan_plotdf2<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)



# needs to be converted to repeat 464 times before progressing to next age bracket
agerange200464<-array(dim=c(200*464,1))
for (i in 1:length(agerange200)){
agerange200464[((464*i)-463):(464*i)]<-rep(agerange200[i],464)
}

# now we need deriv vals of same format, but they will change for every network at every age bracket. Using sig change should take care of whiting out zeros
deriv200464<-array(dim=c(200*464,1))
for (i in 1:length(agerange200)){
deriv200464[((464*i)-463):(464*i)]<-derivInfo[,i]
}

LongAgeSpan_plotdf2<-data.frame(sapply(AgeSpan_plotdf2,rep.int,times=200))
LongAgeSpan_plotdf2$agespans<-agerange200464
LongAgeSpan_plotdf2$derivs<-deriv200464

ggplot(LongAgeSpan_plotdf2,aes(agespans,tmvec,color=derivs,group=CIgroupingInd)) +geom_line(size=5,alpha=.8) +labs(title='Network Segregation Effect Manifestation', x = 'Age', y = 'Transmodality') +theme_classic(base_size = 28)+ xlim(c(8,23))+ scale_colour_gradientn(colours=c('#ffe900','#ddcd78','white','#888fac','#002a72'),values = c(0,.05,.265,.615,1),name="Change Per Year")


```

```{r}
# With the smooths overlaid
AgeSpan_plotdf3<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
LongAgeSpan_plotdf3<-data.frame(sapply(AgeSpan_plotdf3,rep.int,times=693))


# assign same transmodality value to each point on same lines
Transmodality693464<-array(dim=c(693*464,1))
for (i in 1:464){
Transmodality693464[((693*i)-692):(693*i)]<-tmvec[i]
}
LongAgeSpan_plotdf3$Transmodality<-Transmodality693464

# grouping index so all points of same line have CIgroupingInd in common
GroupingInd693464<-array(dim=c(693*464,1))
for (i in 1:464){
GroupingInd693464[((693*i)-692):(693*i)]<-CIgroupingInd[i]
}

LongAgeSpan_plotdf3$Grouping<-GroupingInd693464


# ports actual splines in
NetSplines693464<-array(dim=c(693*464,1))
for (i in 1:464){
NetSplines693464[((693*i)-692):(693*i)]<-NetSplines[i,]
}
LongAgeSpan_plotdf3$Splines<-NetSplines693464


# put this guy through the same wrangling ringer as the "estimated age", which is how the spline is ported in

NetSplinesAgeSideCar693464<-array(dim=c(693*464,1))
for (i in 1:464){
NetSplinesAgeSideCar693464[((693*i)-692):(693*i)]<-masterdf$Age
}
LongAgeSpan_plotdf3$Age<-NetSplinesAgeSideCar693464/12




# [1:4851] plots first 7 networks (693 points for each)
ggplot(LongAgeSpan_plotdf3,aes(Age,Splines,color=Transmodality,group=Grouping)) +geom_line(size=1,alpha=.1) +labs(title='Network Segregation Effect Manifestation', x = 'Age', y = 'Predicted Segregation') +theme_classic(base_size = 28)+ xlim(c(8,23))+ scale_colour_gradient(low="#55185D", high="#ECB602")

```

```{r}
#### attempt and trendlines in corrplot, depends on stuff like the covariates call and vectors from the above chunk

# k number of factors for each df/plot, iterative over scales
# SET K
#for(K in 2:30){
  # will use k index to find approp. spot in NetSplines array
  # scratch that, netsplines array is just segreg. we need MORE
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  # scale index
  scaleind<-paste('_scale',K,'_',sep='')
  #pull cols at this scale
  # for individualized only
  scaleind<-grep(scaleind,colnames(masterdf))
  scaleindivind<-intersect(scaleind,indiv)
  #make df with rows as subjects and columns as scaleindivind
  # fill it with the subject wise values from each column, then bestow colnames
  scale_df<-masterdf[scaleindivind]
  scale_df$age<-masterdf$Age
  # array for 693 gam values for each scaleindivind value (gammarray)
  gamma_ray<-array(0,c(693,length(scaleindivind)))
  
  
  
  segcols_inscaleindivind<-intersect(scaleindivind,nsegcols)
  wincols_inscaleindivind<-intersect(scaleindivind,wincols)
  bwcols_inscaleindivind<-intersect(scaleindivind,bwcol)
  
  
  # array for total psuedocorrplot
  plotarray<-t(array(as.character(paste('plot_',seq(1:(K*K)),sep='')),c(K,K)))
  
  for(i in 1:K){
    
    ##### SEGREGATION
    # fill in segregs (K segregs, gam array [1:K])
    # get position of this network in broader scale-specific individualized features index 
    posish<-grep(segcols_inscaleindivind[i],scaleindivind)
    # turn this particular FC feature into a gam
    x<-colnames(masterdf[segcols_inscaleindivind][i])
    form<-as.formula(paste("",x,"", covariates, sep=""))
    igam<-gam(formula = form,data=masterdf)
    # extract spline from igam
    derv<-derivatives(igam,term='Age')
    derv<- derv %>%
    # find where to gray out non-sig trends
    mutate(sig = !(0 >lower & 0 < upper))
    derv$sig_deriv = derv$derivative*derv$sig
    # else {
    #minAgeEst[i]<-min(derv$data[derv$sig==T])
    #maxAgeEst[i]<-max(derv$data[derv$sig==T])
    # changed to color sig deriv only
    #derivInfo[i,]=derv$sig_deriv
    forSpline<-predict(igam, data = masterdf, type = "terms")
    # adding mean val because output values are centered
    gamma_ray[,posish]<-forSpline[,3]+coef(igam)[1]
    # use linear slope from straightdforward age cor to color scheme
    scaledf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,scaleindivind[i]])
    # partial spearmans to extrac age relation
    pspear=pcor(scaledf,method='spearman')$estimate
    linear_segcor<-pspear[4]
    if (all(derv$sig==FALSE)){gamcolor='gray'
    } else if (linear_segcor>0) {gamcolor='blue'
    } else if (linear_segcor<0) {gamcolor='red'
    }
    # With the smooths overlaid
    AgeSpan_plotdf4<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
    LongAgeSpan_plotdf4<-data.frame(sapply(AgeSpan_plotdf4,rep.int,times=693))
    # port age in
    LongAgeSpan_plotdf4$Age<-masterdf$Age/12
    # ports actual splines in
    LongAgeSpan_plotdf4$SegSplines<-forSpline[,3]+coef(igam)[1]
    # will need to change this to input ggplot as a plot within a ggplot vector
    print(ggplot(LongAgeSpan_plotdf4,aes(Age,SegSplines)) +geom_line(size=5,color=gamcolor) +labs(title=paste('Net. Seg. Scale',K,' Net',i,sep=''), x = 'Age', y = 'Predicted Value') +theme_classic(base_size = 28)+ xlim(c(8,23)))
    
    #### WITHIN   
    # fill in withins (K withins, gam array [K+1:2K])
    # get position of this network in broader scale-specific individualized features index 
    posish<-grep(wincols_inscaleindivind[i],scaleindivind)
    # turn this particular FC feature into a gam
    x<-colnames(masterdf[wincols_inscaleindivind][i])
    form<-as.formula(paste("",x,"", covariates, sep=""))
    igam<-gam(formula = form,data=masterdf)
    # extract spline from igam
    derv<-derivatives(igam,term='Age')
    derv<- derv %>%
    # find where to omit non-sig trends
    mutate(sig = !(0 >lower & 0 < upper))
    derv$sig_deriv = derv$derivative*derv$sig
    #if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
    #} else {
    #minAgeEst[i]<-min(derv$data[derv$sig==T])
    #maxAgeEst[i]<-max(derv$data[derv$sig==T])
    # changed to sig deriv only
    #derivInfo[i,]=derv$sig_deriv
    forSpline<-predict(igam, data = masterdf, type = "terms")
    # adding mean val because output values are centered
    gamma_ray[,posish]<-forSpline[,3]+coef(igam)[1]
    # use linear slope from straightdforward age cor to color scheme
    scaledf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,scaleindivind[posish]])
    # partial spearmans to extract age relation
    pspear=pcor(scaledf,method='spearman')$estimate
    linear_wincor<-pspear[4]
    if (all(derv$sig==FALSE)){gamcolor='gray'
    } else if (linear_wincor>0) {gamcolor='blue'
    } else if (linear_wincor<0) {gamcolor='red'
    }
    # With the smooths overlaid
    AgeSpan_plotdf4<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
    LongAgeSpan_plotdf4<-data.frame(sapply(AgeSpan_plotdf4,rep.int,times=693))
    # port age in
    LongAgeSpan_plotdf4$Age<-masterdf$Age/12
    # ports actual splines in
    LongAgeSpan_plotdf4$WinSplines<-forSpline[,3]+coef(igam)[1]
    # will need to change this to input ggplot as a plot within a ggplot vector
    winplot<-ggplot(LongAgeSpan_plotdf4,aes(Age,WinSplines)) +geom_line(size=5,color=gamcolor) +labs(title=paste('Net. Win. Scale',K,' Net',i,sep=''), x = 'Age', y = 'Predicted Value') +theme_classic(base_size = 28)+ xlim(c(8,23))
    
    # fit WITHIN to diagonals of plot array
    plotarraywin<-diag(plotarray)
    assign(plotarraywin[i],winplot)
    
    # the big betweenchillada 
    #throw another loop in here, one segreg/win value per net but many b/w conn values
    ###  BETWEEN
    # make off diagonal plot array for filling
    # annoying fix for top triangle where it was counting sequentially over columns instead of rows 
    toptri<-t(plotarray)[lower.tri(plotarray)]
    # and bottom
    bottri<-plotarray[lower.tri(plotarray)]
    for (b in 1:length(bwcols_inscaleindivind)){
    # fill in betweens ( ((K-1)*(K))/2 betweens [2K+1: 2K + (((K-1)*(K))/2))])
    posish<-grep(bwcols_inscaleindivind[b],scaleindivind)
    x<-colnames(masterdf[bwcols_inscaleindivind][b])
    form<-as.formula(paste("",x,"", covariates, sep=""))
    igam<-gam(formula = form,data=masterdf)
    # extract spline from igam
    derv<-derivatives(igam,term='Age')
    derv<- derv %>%
    # find where to omit non-sig trends
    mutate(sig = !(0 >lower & 0 < upper))
    derv$sig_deriv = derv$derivative*derv$sig
    #if (all(derv$sig==FALSE)){minAgeEst[i]=0; maxAgeEst[i]=0
    #} else {
    #minAgeEst[i]<-min(derv$data[derv$sig==T])
    #maxAgeEst[i]<-max(derv$data[derv$sig==T])
    # changed to sig deriv only
    #derivInfo[i,]=derv$sig_deriv
    forSpline<-predict(igam, data = masterdf, type = "terms")
    # adding mean val because output values are centered
    gamma_ray[,posish]<-forSpline[,3]+coef(igam)[1]
    # use linear slope from straightdforward age cor to color scheme
    scaledf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,scaleindivind[posish]])
    # partial spearmans to extract age relation
    pspear=pcor(scaledf,method='spearman')$estimate
    linear_wincor<-pspear[4]
    if (all(derv$sig==FALSE)){gamcolor='gray'
    } else if (linear_wincor>0) {gamcolor='blue'
    } else if (linear_wincor<0) {gamcolor='red'
    }
    # With the smooths overlaid
    AgeSpan_plotdf4<-data.frame(tmvec,scalesvec,domnetvec,corVecEst,netpropvec,CIgroupingInd)
    LongAgeSpan_plotdf4<-data.frame(sapply(AgeSpan_plotdf4,rep.int,times=693))
    # port age in
    LongAgeSpan_plotdf4$Age<-masterdf$Age/12
    # ports actual splines in
    LongAgeSpan_plotdf4$BwSplines<-forSpline[,3]+coef(igam)[1]
    # will need to change this to input ggplot as a plot within a ggplot vector
    bwplot<-ggplot(LongAgeSpan_plotdf4,aes(Age,BwSplines)) +geom_line(size=5,color=gamcolor) +labs(title=x, x = 'Age', y = 'Predicted Value') +theme_classic(base_size = 28)+ xlim(c(8,23))     
    # fit BETWEEN to off-diagonals of plot array
    # get top triangle off diagonals
    assign(toptri[b],bwplot)
    assign(bottri[b],bwplot)
    }
  

}
plotvec<-c(print(plotarray,quote = F))
plotveccommas<-paste(plotvec,collapse=",")
ggarrangecommand<-paste('ggarrange(',plotveccommas,',ncol=K,nrow=K)',sep='')
eval(parse(text=ggarrangecommand)) 

```


```{r}
set.seed(417)
library(plotly)
temp <- sample(20:60,100,replace = T)
pressure <- sample(50:100,100,replace = T)
dtime <- sample(50:100,100,replace = T)

axx <- list(
  range = c(0,100)
)

axy <- list(
  range = c(0,100)
)

axz <- list(
  range = c(0,100)
)

scene = list(
  xaxis = axx,
  yaxis = axy,
  zaxis = axz,
  camera = list(eye = list(x = -1.25, y = 1.25, z = 1.25)))

fig<-plot_ly(x=temp, y=pressure, z=dtime, type="scatter3d", mode="markers", color=temp)

fig <- fig %>% layout(title = "3D Scatter plot", scene = scene)
```


```{r}
# Spatial dispersement of network
library(ggpointdensity)
LHpi<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/numPatches_LH_allscales.csv')
RHpi<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/numPatches_RH_allscales.csv')

Seg_CIplotdf$LH_patchnum<-LHpi$patchnum_over_scalesL
Seg_CIplotdf$RH_patchnum<-RHpi$patchnum_over_scalesR
Seg_CIplotdf$Tot_patchnum<-Seg_CIplotdf$LH_patchnum+Seg_CIplotdf$RH_patchnum

ggplot(Seg_CIplotdf,aes(Tot_patchnum,corVecEst,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_point(size=4,aes(Tot_patchnum,corVecEst))+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Total Number of Patches") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Networks')+ ylim(-.5,.5)

ggplot(Seg_CIplotdf,aes(tmvec,Tot_patchnum,color=domnetvec,alpha=netpropvec^2,group=V7))+ geom_point(size=4,aes(tmvec,Tot_patchnum)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("Total Patch number") +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Networks')

ggplot(Seg_CIplotdf,aes(tmvec,Tot_patchnum,color=scalesvec,group=V7))+ geom_point(size=4,aes(tmvec,Tot_patchnum)) +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Networks')+ scale_colour_gradient(low="#55185D", high="#ECB602")


ggplot(Seg_CIplotdf,aes(tmvec,Tot_patchnum))+ geom_pointdensity(size=4, adjust = 3)+ xlab("Transmodality") + ylab("Total Patch number")

ggplot(Seg_CIplotdf,aes(corVecEst,Tot_patchnum))+ geom_pointdensity(size=4)+ xlab("Transmodality") + ylab("Total Patch number")
```

```{r}

### BY THE POWER OF OUR INDICES COMBINED!
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]
# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# empty array to populate with b/w connectivity age cors (b/w to unimodal, b/w to transmodal, b/w to aggregate, and K and N and Modality just to confirm we are matching)
bwAgeCorVecs<-matrix(0,464,6)

# loop over connectivities to unimodal then to transmodal
modalloopvar=c('unimodal','transmodal')
for (i in 1:2){
  print(modalloopvar[i])
  # get "the other"
  modalloopvar_other=modalloopvar[modalloopvar!=(modalloopvar[i])]
  # extract which of 1:464 network mappings match the modalitity of this loop
  modalindices=which(tmclass %in% modalloopvar[i])
  # loop over each scale
    for (K in 2:30){
    # Make index of where values from this K should go
      K_start=((K-1)*(K))/2
      K_end=(((K-1)*(K))/2)+K-1
      Kind<-K_start:K_end
      bwAgeCorVecs[Kind,4]=K
    
    # index which values are at this scale
    scaleStr=paste('scale',K,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
    # extract within and between colnames at this scale for within->b/w binarized transmodality mapping
    wincolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),wincolnames)
    wincolnames_thisScale=wincolnames[wincolnames_thisScale_inds]
    bwcolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),bwcolnames)
    bwcolnames_thisScale=bwcolnames[bwcolnames_thisScale_inds]
    
  # one weird trick to get binarized transmodality class vector for same scale (Doctors hate him!)
    # tm naming aligns with wincon naming
    tmclasses_thisScale<-tmclass[wincolnames_thisScale_inds]
    # extract the network number of each network at this scale in same order as tmclasses_thisScale
    wincolNamesSplit<-strsplit(wincolnames_thisScale,"_net")
    wincolNames_net<-sapply(wincolNamesSplit, "[[" , 2)
    # mini matching vectors with network label at this scale in one col and transmodality binarization in the other
    tmMatchingVecs<-cbind(wincolNames_net,tmclasses_thisScale)
    # remove scale number from strings so we're not picking up on those
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    bwnetnames_thisScale<-wincolNames_net<-sapply(bwcolnames_thisScale_split, "[[" , 2)
    # add another fucking set of underscores to all of these colnames so 1's dont pick up 10s
    bwnetnames_thisScale_extended<-paste('ind_bw_FC_scale',K,'_nets_',bwnetnames_thisScale,'_',sep='')
    # extra goddamn undercores have to go here and be removed later
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    # to be matched in all-networks-at-this-scale loop
    # now as we descend into the third circle of for-loop hell, we find the guy from man vs.food being eaten alive by cerberus
    for (N in 1:K){
      # generate index for where values for this network at this scale should reside
      # start from K index
      Nind<-Kind[N]
      bwAgeCorVecs[Nind,5]=N
      # get index for this N in terms of masterdf (collapse | to match multiple patterns)
      Ncolname<-grep(as.character(paste('_',N,'_',sep='')),bwnetnames_thisScale_extended,value=T)
      # need to add "_" before and after each number so I can select for '_N_' and not pick up teens digits with 1, 20s with 3, 15 and 25 with 5, etc.
      # determine if this network is transmodal or unimodal
      NModality<-tmMatchingVecs[,2][[N]]
      ########bwAgeCorVecs[Nind,6]<-NModality
      NotNModality<-modalloopvar[modalloopvar!=NModality]
      matchvec<-grep(NModality,tmclasses_thisScale)
      # remove self
      matchvec<-matchvec[matchvec!=N]
      # build index of matching modalities to reference masterdf (collapse | to match multiple patterns)
      matchTruncColName<-grep(as.character(paste('_',matchvec,'_',sep='',collapse="|")),Ncolname,value=T)
      # remove first and last characters now that we are specific
      #matchTruncColName<-sub('.$','',matchTruncColName)
      #matchTruncColName<-sub('.','',matchTruncColName)
      # deal with weird thing where empty space was being grepped because of its aspecificity at coarse scales
      if(length(matchTruncColName)==0){
        matchTruncColName[1]='CANTSEEME'
      }
      match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(matchTruncColName,collapse="|")),bwnetnames_thisScale_extended)
      match_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      
      # deal with weird thing where empty space was being grepped because of its aspecificity
      if(length(match_NetN_scaleK_bw_indivi_cols_names)==0){
        match_NetN_scaleK_bw_indivi_cols_names[1]='CANTSEEME'
      }
      #################
      #### NEED TO ADD UNDERSCORE TO AFTERPORTION SO IT DOESNT PICK UP 1_20 when looking for 1_2 #########
      ##########
      #bwcolnames_thisScale<-paste(bwcolnames_thisScale,'_',sep='')
      #match_NetN_scaleK_bw_indivi_cols_names<-paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='')
      
      # added a faux '_' to end of column to col names can more selectively match numbers (not picking up on 20 when looking for 2, 2_ and 20_ more distinct)
      match_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
    
      ###############
      ######## find opposite modality in this scale ################
      ###############
      
      oppositevec<-grep(NotNModality,tmclasses_thisScale)
      
      # build index of NON-matching modalities to reference masterdf (collapse | to match multiple patterns)
      unmatchTruncColName<-grep(as.character(paste('_',oppositevec,'_',sep='',collapse="|")),Ncolname,value=T)
      # search for string in limited bwcolnames at this scale so as not to invite other scales into this grep party
      # remove first and last characters now that we are specific
      #unmatchTruncColName<-sub('.$','',unmatchTruncColName)
      #unmatchTruncColName<-sub('.','',unmatchTruncColName)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-grep(as.character(paste(unmatchTruncColName,collapse="|")),bwnetnames_thisScale_extended,value=T)
      
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,collapse="|")),bwnetnames_thisScale_extended)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      unmatch_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
      
      
      # doublecheck that they are mutually exclusive (+1 because self-reference gets removed)
    #  if(length(tmclasses_thisScale)!=length(matchvec)+length(oppositevec)+1){
   #     print('You done goofed, internet police are on their way')
     # }
      if(length(tmclasses_thisScale)!=length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1){
        print('Names dont add up chief')
        paste('match numbas', length(match_NetN_scaleK_bw_indivi_cols_ind), length(match_NetN_scaleK_bw_indivi_cols_names))
        paste('unmatch numbas', length(unmatch_NetN_scaleK_bw_indivi_cols_ind), length(unmatch_NetN_scaleK_bw_indivi_cols_names))
        stopifnot(length(tmclasses_thisScale)==length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1)
      }
      unmatch_NetN_scaleK_bw_indivi_cols_ind
      # Reset these to NULL for each loop over N for equivalent looping
      
      
      # if it matches the modality being aggregated in the grandparent loop, we wish to only assay its connections to same-modality networks
      if (NModality==modalloopvar[i] && length(matchvec>0)){
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_same<-rowMeans(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind,drop=F])
        # get mean agecor with matching networks
        avg_bw_agecor<-corEstVec(avg_bw_same)
      } else if (NModality!=modalloopvar[i]) {  
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_dif<-rowMeans(masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
        # get mean agecor with non-matching networks
        avg_bw_agecor<-corEstVec(avg_bw_dif)
      } else if (NModality==modalloopvar[i] && (exists("matchvec[1]"))=='FALSE') {
        # easily findable index for cells which should not be filled (i.e., there is no "to unimodal connectivity" for the only unimodal networks at any scale)
        avg_bw_agecor<-999
      }
      # if it does not match the modality of the grandparent loop, we wish go assay its connections to opposite-modality networks
      bwAgeCorVecs[Nind,i]=avg_bw_agecor
    # get average bw network connectivty age correlation for this network at this scale
      both=cbind(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind],masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
      avg_bw=rowMeans(both)
      avg_bw_coarse_agecor<-corEstVec(avg_bw)
      bwAgeCorVecs[Nind,3]=unlist(avg_bw_coarse_agecor)
    }
    # Print out ratio of transmodal to unimodal at this scale
    unilength=length(tmclasses_thisScale[tmclasses_thisScale=='unimodal'])
    translength=length(tmclasses_thisScale[tmclasses_thisScale=='transmodal'])
    print(paste('uni to trans ratio:', unilength/translength))
  }
  
}
bwAgeCorVecs<-data.frame(bwAgeCorVecs)
```
```{r}
# temp version
tmumRatVec<-c(1,2,1,0.666666666666667,1,.75,1.6667,1.25,1,0.833333,1.4,1.1667,1,1.5,1.2857,1.125,1,1.375,1.222,1.1,1,.9166667,.846,1.0833,.8571,.8,1,.8125,.6666)
```


```{r}


# analyze between network connectivities' couplings with age by transmodality
colnames(bwAgeCorVecs)<-c('bw_to_unimodal','bw_to_transmodal','avg_bw','K','N')
############ analyze contribution of avg b/w network connectivities' age couplings by scale and transmodality #############

# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)
bwdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)


# avg b/w
avgbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w con avg and Age over All Networks') + ylim(-.5,.5)

avgbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.avg_bw,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")

# b/w to unimodal
unibw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWUCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w unimodal con and Age over All Networks')+ ylim(-.5,.5)

unibw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWUCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# b/w to transmodal
transbw_age_tm<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWTCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w transmodal con and Age over All Networks')+ ylim(-.5,.5)

transbw_age_scale<-ggplot(bwdf,aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWTCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

ggarrange(avgbw_age_tm,unibw_age_tm,transbw_age_tm,avgbw_age_scale,unibw_age_scale,transbw_age_scale)

#17 network version
bwdf17<-data.frame(tmvec,scalesvec,domnetvec17,netpropvec17,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)

Segreg_age_tm17<-ggplot(bwdf17,aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec17,alpha=netpropvec17^2)) + scale_color_manual(values=c('#dc8303','#8d2049','#596a85','#2d9a3d','#007938','#d9e200','#bc0943','#2b1f67','#48593a','#91a967','#4183a8','#00bb89','#3245a3','#9e3ca2','#eb75b3','#68126f','#d1001c')) + xlab("Transmodality") + ylab("AgeB/WCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,bwAgeCorVecs.avg_bw)) + ggtitle('Correlation of B/w Con Avg and Age over All Communities')+ ylim(-.5,.5)
```

```{r}
#### now make it for group template-measured FC vaues, starting with within and segreg
############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
gro_wincols_ind<-intersect(wincols,group)
group_scalebynet_df<-masterdf[,gro_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(group_scalebynet_df)


#confvecupper<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfvecupper))
#confveclower<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,gro_wincols_ind],corEstVec))
#confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
#confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
GWin_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
#corVecEst_d[,6]<-CIgroupingInd

# plot it
Win_age_tm_gro<-ggplot(GWin_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Connectivity and Age over All Networks (GRO)')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale_gro<-ggplot(GWin_plotdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# pull out scale x network segregation for individualized maps
gro_nsegcols_ind<-intersect(nsegcols,group)
gro_scalebynet_df<-masterdf[,gro_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(gro_scalebynet_df)

corVecEst<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corEstVec))

GSeg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

Segreg_age_tm_gro<-ggplot(GSeg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Segregation and Age over All Networks (GRO)')+ ylim(-.5,.5)

Segreg_age_scale_gro<-ggplot(GSeg_plotdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)


ggarrange(Segreg_age_tm_gro,Segreg_age_scale_gro,Win_age_tm_gro,Win_age_scale_gro)
```

```{r}

# quick plot of each vertices' change in age-org relation over scales and transmodality
f=read.csv('/cbica/projects/pinesParcels/results/aggregated_data/ScaleAgeWin_TM_interaction.csv')
library(ggpointdensity)
ggplot(f,aes(x=CMTM,y=Var2)) + geom_pointdensity(adjust=.5) + scale_color_viridis_c() +xlab('Transmodality') + ylab('Change in Age-Within Relation (Slope) over Scales')

ggplot(f,aes(x=CMTM,y=Var2)) + geom_point(alpha=.08,size=2) +xlab('Transmodality') + ylab('Change in Age-Within Relation (Slope) over Scales')

# and for Between
f2=read.csv('/cbica/projects/pinesParcels/results/aggregated_data/ScaleAgeBw_TM_interaction.csv')
ggplot(f2,aes(x=CMTM,y=Var2)) + geom_pointdensity(adjust=.3) + scale_color_viridis_c() +xlab('Transmodality') + ylab('Change in Age-Between Relation (Slope) over Scales')

ggplot(f2,aes(x=CMTM,y=Var2)) + geom_point(alpha=.08,size=2) +xlab('Transmodality') + ylab('Change in Age-Between Relation (Slope) over Scales')

```


```{r}
# Framework for pairwise age patterns
# Transmodality Dif and Age-relation
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]

# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# initialize empty tm difference vector and age effect vector 
tmdifvec=NULL
ageEfvec=NULL

# make a scale vector to match transmodality difference values
# this is to look at how finer scales confer networks that are less different
scalevec=NULL

## for all b/w cols
for (i in 1:length(colnames(individ_scalebybw_df))){
    #print(i)
    # extract column name. Will parse column name to determine nature of #connection
    curcolname<-colnames(individ_scalebybw_df)[i]
    splitname<-unlist(strsplit(curcolname,'_'))
    scalefield=splitname[4]
    net1field=splitname[5]
    net2field=splitname[7]
    # doctor up scale and net1field so they are exclusively the value of #interest
    scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
    net1=unlist(strsplit(net1field,'s'))[2]
    net2=net2field 
    # helping phriendly index
    K_start=((scale-1)*(scale))/2
    K_end=(((scale-1)*(scale))/2)+scale-1
    Kind<-K_start:K_end
    # get TM values of both nets at this scale
    tm1=tmvec[Kind[as.numeric(net1)]]
    tm2=tmvec[Kind[as.numeric(net2)]]
    # absolute value as directionality is meaningless here
    tmdif=abs(tm1-tm2)
    # get position in master df of this column (need to use \b for exact matches #only)
    curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
    colindex<-grep(curcolnameexact,colnames(masterdf))
    # get Age relation controlling for sex and motion
    pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex])
    # partial spearmans to extrac age relation
    pspear=pcor(pcordf,method='spearman')$estimate
    # save both to respective vectors
    tmdifvec<-append(tmdifvec,tmdif)
    ageEfvec<-append(ageEfvec,pspear[4])
    # accompanying scalevec so we can look at the typical transmodality #difference at each scale
    scalevec=append(scalevec,scale)
}

## merged vectors
BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)
ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + geom_point(alpha=.07,size=5) + xlab('Transmodality Difference') + ylab('Age #Correlation') + ggtitle('Pairwise Between-Network Age-FC Relations')
#
## combine scalevec and transmodality dif vec for transmodality difference #differences
#ScaleTMDifDf<-data.frame(tmdifvec,scalevec)
#ScaleTMDifMeanVec<-rep(0,29)
#for (K in 2:30){
#  # Pull out values at this scale
#  ScaleDF<-ScaleTMDifDf[ScaleTMDifDf$scalevec==K,]
#  # Average Values at this scale (K-1 because 1st scale is 2)
#  ScaleTMDifMeanVec[K-1]=mean(ScaleDF$tmdifvec)
#  }
#    
#plot(ScaleTMDifMeanVec)
#
#ggplot(ScaleTMDifDf,aes(x=scalevec,y=tmdifvec)) + geom_point(alpha=.1,size=2) #+xlab('Number of Communities') + ylab('B/W Transmodality Difference')





# seperate out types of pairwise connections to see if unimodal networks reach out over larger transmodality gaps to integrate over age (if transmodality is a measure of how "DMN" a region is, it will underestimate intrinsic differences between things like motor and visual if they are equally "non-dmn" )

# make a vector of each y7 network so i can loop over it instead of makingn 7 different loops
Y7vec<-c('Motor','Visual','DA','VA','Limbic','FP','DM')
# set yeo colorset
ycolors=c('#3281ab','#670068','#007500','#b61ad0','#b8cf86','#d77d00','#c1253c')

#
## for all y7 nets
#for (y in 1:7){
#  # net looked at in this iteration
#  print(Y7vec[y])
#  tmdifvec=NULL
#  ageEfvec=NULL
#  # isolate this net by getting indices of where it is in the 464 vector
#  curY7NetInd<-grep(Y7vec[y],domnetvec)
#  # for all b/w cols
#  for (i in 1:length(colnames(individ_scalebybw_df))){
#      #print(i)
#      # extract column name. Will parse column name to determine nature of #connection
#      curcolname<-colnames(individ_scalebybw_df)[i]
#      splitname<-unlist(strsplit(curcolname,'_'))
#      scalefield=splitname[4]
#      net1field=splitname[5]
#      net2field=splitname[7]
#      # doctor up scale and net1field so they are exclusively the value of #interestx
#      scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
#      net1=unlist(strsplit(net1field,'s'))[2]
#      net2=net2field 
#      # helping phriendly index
#      K_start=((scale-1)*(scale))/2
#      K_end=(((scale-1)*(scale))/2)+scale-1
#      Kind<-K_start:K_end
#      # ONLY include if one network is equal to currently indexed Y7 network
#      y7lab1=domnetvec[Kind[as.numeric(net1)]]
#      y7lab2=domnetvec[Kind[as.numeric(net2)]]
#      if (y7lab1 == Y7vec[y] || y7lab2 == Y7vec[y]){
#      # get TM values of both nets at this scale
#      tm1=tmvec[Kind[as.numeric(net1)]]
#      tm2=tmvec[Kind[as.numeric(net2)]]
#      # absolute value as directionality is meaningless here
#      tmdif=abs(tm1-tm2)
#      # get position in master df of this column (need to use \b for exact #matches only)
#      curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
#      colindex<-grep(curcolnameexact,colnames(masterdf))
#      # get Age relation controlling for sex and motion
#      pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex#])
#      # partial spearmans to extrac age relation
#      pspear=pcor(pcordf,method='spearman')$estimate
#      # save both to respective vectors
#      tmdifvec<-append(tmdifvec,tmdif)
#      ageEfvec<-append(ageEfvec,pspear[4])
#      }
#  }
#  # merged vectors
#  BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)
#  print(ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + #geom_point(alpha=.17,size=5) + xlab('Transmodality Difference') +  ylim(-.4,.4) #+xlim(-.1,13)+ ylab('Age Correlation') + ggtitle(paste('Pairwise Between-Network #Age-FC Relations - ',Y7vec[y]))) 
#}

# for all y7 nets (EXCLUSIVE VERSION)

for (y in 1:7){
  # net looked at in this iteration
  print(Y7vec[y])
  # color used for this iter
  itercolor=ycolors[y]
  tmdifvec=NULL
  ageEfvec=NULL
  # isolate this net by getting indices of where it is in the 464 vector
  curY7NetInd<-grep(Y7vec[y],domnetvec)
  # for all b/w cols
  for (i in 1:length(colnames(individ_scalebybw_df))){
      #print(i)
      # extract column name. Will parse column name to determine nature of connection
      curcolname<-colnames(individ_scalebybw_df)[i]
      splitname<-unlist(strsplit(curcolname,'_'))
      scalefield=splitname[4]
      net1field=splitname[5]
      net2field=splitname[7]
      # doctor up scale and net1field so they are exclusively the value of interestx
      scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
      net1=unlist(strsplit(net1field,'s'))[2]
      net2=net2field 
      # helping phriendly index
      K_start=((scale-1)*(scale))/2
      K_end=(((scale-1)*(scale))/2)+scale-1
      Kind<-K_start:K_end
      # ONLY exclude if one network is equal to currently indexed Y7 network
      y7lab1=domnetvec[Kind[as.numeric(net1)]]
      y7lab2=domnetvec[Kind[as.numeric(net2)]]
      if (y7lab1 != Y7vec[y] && y7lab2 != Y7vec[y]){
      # get TM values of both nets at this scale
      tm1=tmvec[Kind[as.numeric(net1)]]
      tm2=tmvec[Kind[as.numeric(net2)]]
      # absolute value as directionality is meaningless here
      tmdif=abs(tm1-tm2)
      # get position in master df of this column (need to use \b for exact matches only)
      curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
      colindex<-grep(curcolnameexact,colnames(masterdf))
      # get Age relation controlling for sex and motion
      pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex])
      # partial spearmans to extrac age relation
      pspear=pcor(pcordf,method='spearman')$estimate
      # save both to respective vectors
      tmdifvec<-append(tmdifvec,tmdif)
      ageEfvec<-append(ageEfvec,pspear[4])
      }
  }
  # get correlation
  correl=cor.test(tmdifvec,ageEfvec)
  cor_of_int=round(correl$estimate,3)
  # merged vectors
  BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)
  print(ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + geom_point(alpha=.17,size=5)+ 
  geom_smooth(method='lm',linetype="dashed",color=itercolor,size=2) + xlab('Transmodality Difference') +  ylim(-.4,.4) +xlim(-.1,13)+ ylab('Age Correlation') + ggtitle(paste('Pairwise Between-Network Age-FC Relations - ',Y7vec[y], ' excluded',sep=''))+geom_text(x=11,y=.3,label=paste('r =', cor_of_int))) 
}


```

```{r}
### Corresponding within by transmodality plot
# Transmodality Dif and Age-relation
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]

# to later use wincolnames to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)

# initialize empty age effect vector 
ageEfvec=NULL

# make a scale vector to match transmodality difference values
# this is to look at how finer scales confer networks that are less different
scalevec=NULL

## for all b/w cols
for (i in 1:length(colnames(individ_scalebybw_df))){
    #print(i)
    # extract column name. Will parse column name to determine nature of #connection
    curcolname<-colnames(individ_scalebybw_df)[i]
    splitname<-unlist(strsplit(curcolname,'_'))
    scalefield=splitname[4]
    net1field=splitname[5]
    net2field=splitname[7]
    # doctor up scale and net1field so they are exclusively the value of #interest
    scale=as.numeric(unlist(strsplit(scalefield,'e'))[2])
    net1=unlist(strsplit(net1field,'s'))[2]
    net2=net2field 
    # helping phriendly index
    K_start=((scale-1)*(scale))/2
    K_end=(((scale-1)*(scale))/2)+scale-1
    Kind<-K_start:K_end
    # get TM values of both nets at this scale
    tm1=tmvec[Kind[as.numeric(net1)]]
    tm2=tmvec[Kind[as.numeric(net2)]]
    # absolute value as directionality is meaningless here
    tmdif=abs(tm1-tm2)
    # get position in master df of this column (need to use \b for exact matches #only)
    curcolnameexact<-paste('\\',curcolname,'\\b',sep='')
    colindex<-grep(curcolnameexact,colnames(masterdf))
    # get Age relation controlling for sex and motion
    pcordf<-cbind(masterdf$Age,masterdf$Sex,masterdf$Motion,masterdf[,colindex])
    # partial spearmans to extrac age relation
    pspear=pcor(pcordf,method='spearman')$estimate
    # save both to respective vectors
    tmdifvec<-append(tmdifvec,tmdif)
    ageEfvec<-append(ageEfvec,pspear[4])
    # accompanying scalevec so we can look at the typical transmodality #difference at each scale
    scalevec=append(scalevec,scale)
}

## merged vectors
BwAgeCorTMDifDf<-data.frame(tmdifvec,ageEfvec)
ggplot(BwAgeCorTMDifDf,aes(x=tmdifvec,y=ageEfvec)) + geom_point(alpha=.07,size=5) + xlab('Transmodality Difference') + ylab('Age #Correlation') + ggtitle('Pairwise Between-Network Age-FC Relations')

```


```{r}
# Segregation controlling for between-to-unimodal connectivity

# functions to control for covariates in linear model framework 
#BetWeen UniModal Control
lmEstVecBWUMC<-function(x,foursixfourindex){
  # extract corresponding between network connectivity
  bwAgeCorVecs$
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

```

```{r}
# get the gang together (write out vectors of network metric effect relations)
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
gro_nsegcols_ind<-intersect(nsegcols,group)

# functions to write out the corvec estimates for matlab-based viz
pcorEstVecNsave<-function(x,K,vecIn){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

pcorEstVec_EFNsave<-function(x,K,vecIn){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$F1_Exec_Comp_Cog_Accuracy),as.numeric(masteref$Sex),masteref$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-unlist(pspear[4])
  append(vecIn,corest)
}

# get residuals (constant over loops)
# loop over scales
for (i in 2:30){
  print(i)
  keyphrase<-paste('seg_scale',as.character(i),'_net',sep='')
  scaleind=grep(keyphrase,colnames(masterdf))
  # just individualized for now
  # reads in vector of segreg vals aligned with age vals and scale 
  vec_age<-NULL
  vec_age<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],pcorEstVecNsave,K=i,vecIn=vec_age)
  vecfp_Age<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_Age.csv',sep='')
  write.table(as.numeric(vec_age),vecfp_Age,row.names = F,col.names = F,sep = ',')
  vec_ef<-NULL
  vec_ef<-lapply(masteref[,intersect(indiv_nsegcols_ind,scaleind)],pcorEstVec_EFNsave,K=i,vecIn=vec_ef)
  vecfp_EF<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_EF.csv',sep='')
  write.table(as.numeric(vec_ef),vecfp_EF,row.names = F,col.names = F,sep = ',')
}

# Write em out as matlab readable vectors (K: N1est N2est ... Nnest)
```

```{r}
# same approach to write normative segregation for each network at each scale
SegEstVecNsave<-function(x,K,vecIn){
  # relevant df
  meanSeg<-mean(x)
  append(vecIn,meanSeg)
}

# loop over scales
for (i in 2:30){
  print(i)
  keyphrase<-paste('seg_scale',as.character(i),'_net',sep='')
  scaleind=grep(keyphrase,colnames(masterdf))
  # just individualized for now
  # reads in vector of segreg vals aligned with age vals and scale 
  vec_Seg<-NULL
  vec_Seg<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],SegEstVecNsave,K=i,vecIn=vec_Seg)
  vecfp_Seg<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_mSeg.csv',sep='')
  write.table(as.numeric(vec_Seg),vecfp_Seg,row.names = F,col.names = F,sep = ',')
}
```

```{r}
# longer effect vectors for vertex-wisepc
# also need matlab-reading capacity
#library(rmatio)
#pospc=read.mat('/cbica/projects/pinesParcels/results/aggregated_data/vwise_pospc_allscales_allsubjs.mat')
#h5 can support this file format, but this r does not support h5

### screw it we're regressing in matlab
forMLpc<-cbind(df$bblid,df$Age,df$Motion,df$Sex)
MPpcFN<-'/cbica/projects/pinesParcels/results/EffectVecs/forMLpc.csv'
write.table(forMLpc,MPpcFN,,row.names = F,col.names = F,sep = ',')
```

```{r}
##################### START OF PARTICIPATION COEFFICIENT ######################
# global participation coefficient by age

globPC<-read.csv('/cbica/projects/pinesParcels/results/EffectVecs/avgPC.csv')
NegglobPC<-read.csv('/cbica/projects/pinesParcels/results/EffectVecs/avgNegPC.csv')

colnames(globPC)[1]<-'bblid'
colnames(NegglobPC)[1]<-'bblid'

globPCdf<-merge(df,data.frame(globPC),by='bblid')
NegglobPCdf<-merge(df,data.frame(NegglobPC),by='bblid')

# take out scanid
globPCdf<-globPCdf[,-c(2)]
NegglobPCdf<-NegglobPCdf[,-c(2)]
# change age to years
globPCdf$Age<-globPCdf$Age/12
NegglobPCdf$Age<-NegglobPCdf$Age/12

colnames(globPCdf)[5:33]<-as.character(2:30)
colnames(NegglobPCdf)[5:33]<-as.character(2:30)

globPCdfMotSexCor<-globPCdf
NegglobPCdfMotSexCor<-NegglobPCdf

######## end of data tidying - below not adapted for neg yet (use find and replace in sep. chunk)


######## Comment this out to run on positive PC again
###globPCdfMotSexCor<-NegglobPCdfMotSexCor



for (i in 5:33){
  CLM<-lm(globPCdf[,i]~Motion+Sex,data=globPCdf)
  globPCdfMotSexCor[,i]<-CLM$residuals
  # Add mean so we get real values back out
  globPCdfMotSexCor[,i]<-globPCdfMotSexCor[,i]+mean(globPCdf[,i])
}

mCindglobPC<-melt(globPCdfMotSexCor, id=c(1,2,3,4))

# individual PARTICIPATION COEFFICIENT over scales plots, colored by age ##
indPC<-ggplot(data=mCindglobPC,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12,size=1.5)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. PartCoef") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Participation Coef.")


### get global PARTICIPATION COEFFICIENT 
### Now with motion + sex control
# 29 for scales studied
ind_pccors<-matrix(0,29,2)
ind_pccors[,1]<-2:30

# 7/11 - testing across age ranges for that dependence
indglobpc_813<-subset(globPCdf,globPCdf$Age<13)
indglobpc_1318<-subset(globPCdf,globPCdf$Age>13 & globPCdf$Age <18)
indglobpc_1823<-subset(globPCdf,globPCdf$Age>18)

#### repeated ggpplot uses residuals, but pspear and cor over scales uses simultaneously fit spear-men
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(globPCdfMotSexCor,aes(Age,globPCdfMotSexCor[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global PC at Scale", i+1)))
  
  
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(globPCdf$Age,globPCdf$Sex,globPCdf$Motion,globPCdf[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_pccors[i,2]<-pspear[4]
}


indagecorPC<-correlations_over_scales(ind_pccors,"Global Participation Coef Age Correlation - Individ. Partitions")
ggarrange(indPC,indagecorPC,ncol = 1)
ind_pccors_df<-data.frame(ind_pccors)

#### age segment-specific plots
########younguns###########
ind_pccorsy<-matrix(0,29,2)
ind_pccorsy[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobpc_813$Age,indglobpc_813$Sex,indglobpc_813$Motion,indglobpc_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_pccorsy[i,2]<-pspear[4]
}

youngindagecor<-correlations_over_scales(ind_pccorsy,"Global Partif. Coef. Age Correlation - 8-13 Year Olds")

ind_pccorsy_df<-data.frame(ind_pccorsy)

###########mids##############
ind_pccorsm<-matrix(0,29,2)
ind_pccorsm[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobpc_1318$Age,indglobpc_1318$Sex,indglobpc_1318$Motion,indglobpc_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_pccorsm[i,2]<-pspear[4]
}

midindagecor<-correlations_over_scales(ind_pccorsm,"Global Partif. Coef. Age Correlation - 13-18 Year Olds")

ind_pccorsm_df<-data.frame(ind_pccorsm)


###########geezers##########
ind_pccorsg<-matrix(0,29,2)
ind_pccorsg[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobpc_1823$Age,indglobpc_1823$Sex,indglobpc_1823$Motion,indglobpc_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_pccorsg[i,2]<-pspear[4]
}


oldindagecor<-correlations_over_scales(ind_pccorsg,"Global Partif. Coef. Age Correlation - 18-23 Year Olds")


ind_pccorsg_df<-data.frame(ind_pccorsg)


ageBreakDown<-ggarrange(indagecorPC,youngindagecor,midindagecor,oldindagecor)


# merged
mergeddf<-merge(ind_pccors_df,ind_pccorsy_df,by="X1")
mergeddf<-merge(mergeddf,ind_pccorsm_df,by="X1")
mergeddf<-merge(mergeddf,ind_pccorsg_df,by='X1')
colnames(mergeddf)<-c("X1","All","Young","Mid","Old")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","AgeBracket","value")
allpc<-ggplot(x,aes(X1,value,group=AgeBracket,color=AgeBracket)) + geom_step(size=3)+ylab('ParCoef-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
  geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("white","green", "blue","red"))+ggtitle("Global Part.Coef. and Age Correlation Over Scales")

#### re-iterating global seg for comparison
ind_gseg_df<-data.frame(ind_segcorsa)
ind_gsegy_df<-data.frame(ind_segcorsy)
ind_gsegm_df<-data.frame(ind_segcorsm)
ind_gsegg_df<-data.frame(ind_segcorsg)

mergeddf<-merge(ind_gseg_df,ind_gsegy_df,by="X1")
mergeddf<-merge(mergeddf,ind_gsegm_df,by="X1")
mergeddf<-merge(mergeddf,ind_gsegg_df,by='X1')
colnames(mergeddf)<-c("X1","All","Young","Mid","Old")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","AgeBracket","value")
allseg<-ggplot(x,aes(X1,value,group=AgeBracket,color=AgeBracket)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
  geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("white","none", "none","none"))+ggtitle("Global Segregation and Age Correlation Over Scales")


ggarrange(allseg,allpc)
```

```{r}
# network-wise PC effects
# load in the network-PC vals
pcNetVals<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/NetworkWisePCVals.csv')
colnames(pcNetVals)[1]<-'bblid'
# used same matlab code to get these, same colname order applies
colnames(pcNetVals)[2:465]<-colnames(masterdf[,indiv_nsegcols_ind])

# PC-specific DF
pcmasterdf<-merge(pcNetVals,df,by='bblid')


PCcorVecEst<-as.numeric(lapply(pcmasterdf[,2:465],corEstVec))

###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))

PC_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,PCcorVecEst)

PC_age_tm<-ggplot(PC_plotdf,aes(tmvec,PCcorVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("Age PC Cor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,PCcorVecEst)) + ggtitle('Correlation of Network PC and Age over All Communities')+ ylim(-.5,.5)
```

```{r}
# network-wise negative PC effects
# load in the network-PC vals
NegpcNetVals<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/NetworkWiseNegPCVals.csv')
colnames(NegpcNetVals)[1]<-'bblid'
# used same matlab code to get these, same colname order applies
colnames(NegpcNetVals)[2:465]<-colnames(masterdf[,indiv_nsegcols_ind])

# PC-specific DF
pcmasterdf<-merge(NegpcNetVals,df,by='bblid')


NegPCcorVecEst<-as.numeric(lapply(pcmasterdf[,2:465],corEstVec))

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)

NegPC_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,NegPCcorVecEst)

NegPC_age_tm<-ggplot(NegPC_plotdf,aes(tmvec,NegPCcorVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("Age Neg PC Cor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,NegPCcorVecEst)) + ggtitle('Correlation of Network Neg PC and Age over All Communities')+ ylim(-.5,.5)
##################### END OF PARTICIPATION COEFFICIENT #######################
```

```{r}
# load gradstats
grad_sum_df<-read.csv('/cbica/projects/pinesParcels/lambdas_pg1.csv',header=F)
age<-data.frame(demo$ageAtScan1,demo$bblid)
colnames(grad_sum_df)<-c("bblid","grad1lambda")
colnames(age)<-c("age","bblid")
grad_sum_df$bblid<-as.integer(grad_sum_df$bblid)
merged_df<-merge(grad_sum_df,age,by="bblid")
plot(merged_df$age,merged_df$grad1lambda)

# load grad-dm-cors
graddmcor<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/SpatialCorIndK3DMPG1.csv',header=F);
# temp exlcusion of misreads
tmpexcl<-graddmcor[graddmcor[,2]<0.35,1]
#100869 106154 107929 109577 110166 110354 118807 120922 121017 122352 122669 127305 130121 130332 131747  80537  83207
#86690  88190  88859  89063  89534  96201  98879
colnames(graddmcor)[1]<-"bblid"

# make sure Subjects columns are set to same variable class if this doesn't run
testfordmseg<-merge(masterdf,graddmcor,by="bblid")

tempexclind<-which(tmpexcl %in% merged_df$bblid)
merged_df_tmpexcl=testfordmseg[-c(tempexclind),]

plot(merged_df_tmpexcl$V2)

```

```{r}
# patch nums per subj
subjPatchNums<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/SubjPatchNums.csv',skip = 1)
patchByAgeDf<-merge(subjPatchNums,demo,by='bblid')
patchAgecorVec<-rep(0,464)
for (i in 1:464){
  #print(paste(colnames(patchByAgeDf)[i+1]))
  a=cor.test(patchByAgeDf[,i+1],patchByAgeDf$ageAtScan1)
  patchAgecorVec[i]=a$estimate
}

confvecdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,patchAgecorVec)
ggplot(confvecdf,aes(tmvec,patchAgecorVec,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgePatchNumCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,patchAgecorVec)) + ggtitle('Correlation of Total Patch Number and Age over All Communities')+ ylim(-.5,.5)+
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5)+
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5)
```


```{r}
# FC mats with age effects overlaid instead of FC values
library(corrplot)
# going to use domnet vec to assign dominant yeo7 network as colnames
for (K in 2:30){
  # index where this K starts in domnetvec
  K_start=((K-1)*(K))/2
  K_end=(((K-1)*(K))/2)+K-1
  Kind<-K_start:K_end
  AgeEfMatFn=paste('/cbica/projects/pinesParcels/results/EffectMats/fc_ageMat_K',K,'.csv',sep='')
  AgeEfMat=as.matrix(read.csv(AgeEfMatFn))
  colnames(AgeEfMat)<-domnetvec[Kind]
  rownames(AgeEfMat)<-domnetvec[Kind]
  corrplot(AgeEfMat,is.corr = F)
}

```












































































































































































```{r}
### rs only
# motion change
motmerge$Motion <- motmerge$restRelMeanRMSMotion
motiondf<-data.frame(motmerge$bblid,motmerge$Motion)
colnames(motiondf)<-c('bblid','Motion')
###M                 M###

colnames(subjects)<-c("scanid")
colnames(ageSex)<-c("Age","Sex","scanid","bblid")
df<-merge(subjects,ageSex,by="scanid")
df<-merge(df,motiondf,by='bblid')


# load in FC features (takes about 3 minutes) - original file - not loaded in anymore because it tooks forever and new version is just rounded digits to a few decimal places


rsfc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rs.csv')

# set colnames to matlab-printed colnames
colnames(rsfc)<-unlist(rsfc[1,])
# aaaand remove it
rsfc<-rsfc[-c(1),]

rsfc<-data.frame(rsfc)

# round ridiculous number of decimal points
rsfc[] <- lapply(rsfc, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})

colnames(rsfc)[1]<-'bblid'

# trying to re-write the rounded version again
write.csv(rsfc,'/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded_rs.csv',row.names = F)

### it's rounded now bb
rsfc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded_rs.csv')

# isolate shams (although merge should take them out later)
shams<-rsfc[694:695,]

# AGE
masterdf<-merge(rsfc,df,by='bblid')


### isolate global segreg columns
gsegcols<-grep("globseg",colnames(masterdf))
#paste("Indices of global segregation columns at ",gsegcols)

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$Age/12,masterdf$Sex,masterdf$Motion,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "Age","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2,3,4))
mgroglobseg<-melt(groglobseg, id=c(1,2,3,4))

# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales plots, colored by Motion ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Motion)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)

# individual segregation over scales plots, colored by Sex ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.1,size=2)+ theme_minimal(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Sex)) +geom_line(alpha = 0.1,size=2)+ theme_minimal(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)


# formal t.test for gro seg vs ind seg
indsegvec<-as.vector(unlist(indglobseg[,3:31]))
grosegvec<-as.vector(unlist(groglobseg[,3:31]))
t.test(indsegvec,grosegvec,paired=T)



########### Global seg after regressing out motion
# regress effect of age out on sex and motion
indglobseg_motSexC<-indglobseg
groglobseg_motSexC<-groglobseg

# Z-scored for check of my stats knowledge
indglobseg_Zs<-indglobseg

indglobseg_Zs$Age<-(indglobseg$Age-mean(indglobseg$Age))/sd(indglobseg$Age)
indglobseg_Zs$Motion<-(indglobseg$Motion-mean(indglobseg$Motion))/sd(indglobseg$Motion)

for (i in 5:33){
  CLM<-lm(indglobseg[,i]~Motion+Sex,data=indglobseg)
  indglobseg_motSexC[,i]<-CLM$residuals
  GCLM<-lm(groglobseg[,i]~Motion+Sex,data=groglobseg)
  groglobseg_motSexC[,i]<-GCLM$residuals
  
  
  meanval<-mean(indglobseg[,i])
  sdofvals<-sd(indglobseg[,i])
  Zvals<-(indglobseg[,i]-meanval)/sdofvals
  indglobseg_Zs[,i]<-Zvals
}


mCindglobseg<-melt(indglobseg_motSexC, id=c(1,2,3,4))
mCgroglobseg<-melt(groglobseg_motSexC, id=c(1,2,3,4))



# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mCindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")

groseg<-ggplot(data=mCgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_minimal(base_size = 28)+labs(title="M/S-Regressed Glob. Segreg. - Group Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)
```

```{r}
### get global seg cors
### Now with motion + sex control
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30
# make an "all" segcors for plotting a thousand lines down or so
ind_segcorsa<-ind_segcors
# 7/11 - testing across age ranges for that dependence
indglobseg_813<-subset(indglobseg,indglobseg$Age<13)
indglobseg_1318<-subset(indglobseg,indglobseg$Age>13 & indglobseg$Age <18)
indglobseg_1823<-subset(indglobseg,indglobseg$Age>18)
groglobseg_813<-subset(groglobseg,groglobseg$Age<13)
groglobseg_1318<-subset(groglobseg,groglobseg$Age>13 & groglobseg$Age <18)
groglobseg_1823<-subset(groglobseg,groglobseg$Age>18)

#### repeated ggpplot uses residuals, but pspear and cor over scales uses simultaneously fit spear-men
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  print(ggplot(indglobseg_motSexC,aes(Age,indglobseg_motSexC[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Ind Global Segreg at Scale", i+1)))
  
  
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg$Age,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsa[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  print(ggplot(groglobseg,aes(Age,groglobseg[,i+4])) + geom_point() + geom_smooth() +ylab(paste("Gro Global Segreg at Scale", i+1)))
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - Individ. Partitions")
groagecor<-correlations_over_scales(gro_segcors,"Global Segregation Age Correlation - Group Partitions")
ggarrange(indagecor,groagecor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
all<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales")



#### age segment-specific plots
########younguns###########
ind_segcorsy<-matrix(0,29,2)
ind_segcorsy[,1]<-2:30

for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_813$Age,indglobseg_813$Sex,indglobseg_813$Motion,indglobseg_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsy[i,2]<-pspear[4]
}

for (i in 1:29){
  scaledf<-cbind(groglobseg_813$Age,groglobseg_813$Sex,groglobseg_813$Motion,groglobseg_813[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

youngindagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - 8-13 Year Olds")

ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
young<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 8-13 Years")

###########mids##############
ind_segcorsm<-matrix(0,29,2)
ind_segcorsm[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_1318$Age,indglobseg_1318$Sex,indglobseg_1318$Motion,indglobseg_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsm[i,2]<-pspear[4]
}
for (i in 1:29){
  scaledf<-cbind(groglobseg_1318$Age,groglobseg_1318$Sex,groglobseg_1318$Motion,groglobseg_1318[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

midindagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - 13-18 Year Olds")

ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
mid<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 13-18 Years")


###########geezers##########
ind_segcorsg<-matrix(0,29,2)
ind_segcorsg[,1]<-2:30
for (i in 1:29){
  # i+4 because first column is scanid, second is age, third is sex, 4th is motion
  # 7/11 - testing across age ranges for that dependence
  
  # relevant df
  scaledf<-cbind(indglobseg_1823$Age,indglobseg_1823$Sex,indglobseg_1823$Motion,indglobseg_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
  ind_segcorsg[i,2]<-pspear[4]
}

for (i in 1:29){
  scaledf<-cbind(groglobseg_1823$Age,groglobseg_1823$Sex,groglobseg_1823$Motion,groglobseg_1823[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

oldindagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - 18-23 Year Olds")


ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
old<-ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales - 18-23 Years")

ageBreakDown<-ggarrange(indagecor,youngindagecor,midindagecor,oldindagecor)
gro_vs_ind<-ggarrange(all,young,mid,old)

```

```{r}
### get global seg cors FOR EF
# EF
subjbehav<-read.csv("/cbica/projects/pinesParcels/data/n713_Behavior_20181219.csv")
ef<-data.frame(subjbehav$F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
colnames(ef)<-c('F1_Exec_Comp_Cog_Accuracy','bblid')
# merge in
masteref<-merge(masterdf,ef,by='bblid')
### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Sex,masteref$Motion,masteref[,2:30])
groglobseg<-cbind(masteref$bblid,masteref$F1_Exec_Comp_Cog_Accuracy,masteref$Sex,masteref$Motion,masteref[,5455:5483])

# set colnames
colnames(indglobseg)[1:4]<-c("bblid", "EF","Sex","Motion")
colnames(groglobseg)[1:4]<-c("bblid", "EF","Sex","Motion")
colnames(indglobseg)[5:33]<-as.character(2:30)
colnames(groglobseg)[5:33]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30

#### repeated ggpplot uses residuals, NOT SIMULTANEOUSLY FITTED EF COEFFICIENT AT THE MOMENT ### 
### agebeta vec does use simulataneous fit (partial correlations)
for (i in 1:29){
  
  # relevant df
  scaledf<-cbind(indglobseg$EF,indglobseg$Sex,indglobseg$Motion,indglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  ind_segcors[i,2]<-pspear[4]
}

## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){

  # relevant df
  scaledf<-cbind(groglobseg$Age,groglobseg$Sex,groglobseg$Motion,groglobseg[,i+4])
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  gro_segcors[i,2]<-pspear[4]
}

indEFcor<-correlations_over_scales(ind_segcors,"Global Segregation EF Correlation - Individ. Partitions")
groEFcor<-correlations_over_scales(gro_segcors,"Global Segregation EF Correlation - Group Partitions")
ggarrange(indEFcor,groEFcor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-EF Correlation')+
    theme_minimal(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and EF Correlation Over Scales")
```
```{r}

# indicators of processing stream
ind='ind'
gro='gro'
###bts='bts'
###
#### indicators of fc feature type
bwi='_bw_FC_'
wini='_win_FC_'
nsegi='_seg_scale'
###gsegi='_globseg_scale'
###
#### indices of said indicators
indiv=grep(ind,colnames(masterdf))
group=grep(gro,colnames(masterdf))
###basists=grep(bts,colnames(df))
bwcol=grep(bwi,colnames(masterdf))
wincols=grep(wini,colnames(masterdf))
nsegcols=grep(nsegi,colnames(masterdf))
###gsegcols=grep(gsegi,colnames(df))
###
```

```{r}
### analyze relation of transmodality to segregation over scales
### Get in Consensus-reference atlas correspondence
rac<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_yCorrespondence_overscales.csv',stringsAsFactors = F)
scalesvec<-as.numeric(rac[2,])
domnetvec<-as.factor(rac[3,])
netpropvec<-as.numeric(rac[4,])

#### read in transmodality
tm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_transmodality_overscales.csv',stringsAsFactors = F)
colnames(tm)<-tm[1,]
# aaaand remove it
tm<-tm[-c(1),]
tmvec<-as.numeric(tm)

# distribution of transmodality across networks across scales (derived from group consensus)
hist(tmvec,12,xlab="Transmodality",ylab="Count",ylim=c(0,70), main=NULL,col="grey")

# use median transmodality value to split relatively bimodal distribution
medtrans<-median(tmvec)
# equivalent vector to be overwritten with binary classification of transmodality
tmclass<-tmvec
for (i in 1:length(tmclass)){
  if (tmvec[i]<= medtrans){
    tmclass[i]='unimodal'
  }else{
    tmclass[i]='transmodal'
  }
}

############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(individ_scalebywin_df)


########## 7/2/20 - changed to partial correlations to account for sex and motion for each network at each scale

#### Commented out confidence intervals for now, not a feature of the pcor package utilized
# will needs these functions throughout
###corconfinfvecupper<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[1])
###}
###corconfinfveclower<-function(x){
###  confinf<-cor.test(x,masterdf$Age)[9]
###  return(unlist(confinf)[2])
###}

corEstVec<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masterdf$Age),as.numeric(masterdf$Sex),masterdf$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}

# Notice this references master E f, which has 5 fewer subjects
corEstVec_EF<-function(x){
  # relevant df
  scaledf<-cbind(as.numeric(masteref$EF),as.numeric(masteref$Sex),masteref$Motion,x)
  # partial spearmans to extrac age relation
  pspear=pcor(scaledf,method='spearman')$estimate
  corest<-pspear[4]
  return(unlist(corest))
}


###confvecupper<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corEstVec))
###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)
confvecdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###in_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))


# plot it
Win_age_tm<-ggplot(confvecdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale<-ggplot(confvecdf,aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4)+labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = "AgeWinCor", color="Topological \nScale")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ ggtitle('Correlation of Within Network Connectivity and Age over All Communities')+ scale_colour_gradient(low="#55185D", high="#ECB602")
```
```{r}
############ analyze contribution of segregation in network connectivities' age couplings by scale and transmodality #############

# pull out scale x network segregation for individualized maps
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
indiv_scalebynet_df<-masterdf[,indiv_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)

###confvecupper<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfvecupper))
###confveclower<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corEstVec))

###confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
###confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
###confveclower_d[,7]<-CIgroupingInd
###confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
###colnames(confveclower_d)[2]<-"CIbounds"
###colnames(confvecupper_d)[2]<-"CIbounds"
###Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))

Seg_plotdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,corVecEst)

Segreg_age_tm<-ggplot(Seg_plotdf,aes(tmvec,corVecEst,color=domnetvec,alpha=netpropvec^2)) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5)
```

