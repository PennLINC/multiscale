---
title: "Multiscale_statsnfigs"
author: "Adam"
date: "6/7/2020"
output: html_document
---

```{r}
library(shapes)
library(ggplot2)
library(reshape2)
library(dplyr)
library(ggpubr)
library(vroom)
library(mgcv)
# load in demo
demo<-read.csv('/cbica/projects/pinesParcels/data/pnc_demo.csv')
age<-data.frame(demo$ageAtScan1,demo$scanid)
subjects<-read.csv('/cbica/projects/pinesParcels/data/participants.txt',header = F)
# Need to determine best qa file
##qa<-read.csv('~/Desktop/multiscale/n1601_RestQAData_20170318.csv')
colnames(subjects)<-c("scanid")
colnames(age)<-c("Age","scanid")
df<-merge(subjects,age,by="scanid")

# community solutions guaged in this iteration
community_vec<-seq(2,30)

# load in error over scales
numiter=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_n',header = F)
iter_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/iter_error',header = F)
recon_err=read.csv('/cbica/projects/pinesParcels/data/aggregated_data/recon_error',header=F)

# bblids got rounded in matlab csvwrite in this iteration, plug ids directly in
bblids<-read.delim('/cbica/projects/pinesParcels/data/bblids.txt',header=F)
# yes, I double checked that they matched up
numiter$V1<-bblids[,1]
iter_err$V1<-bblids[,1]
recon_err$V1<-bblids[,1]

# calculate difference
dfdif=iter_err
dfdif[,2:30]=iter_err[,2:30]-recon_err[2:30]

# get ages in there
ages<-data.frame(demo$ageAtScan1,demo$bblid)
colnames(ages)<-c("Age","bblid")

colnames(iter_err)[1]<-"bblid"
colnames(numiter)[1]<-"bblid"
colnames(recon_err)[1]<-"bblid"
colnames(dfdif)[1]<-"bblid"

df_tc<-merge(ages,iter_err,by="bblid")
df_ni<-merge(ages,numiter,by="bblid")
df_rc<-merge(ages,recon_err,by="bblid")
df_dif<-merge(ages,dfdif,by="bblid")

mdata<-melt(df_tc,id=c(1,2))
mdatani<-melt(df_ni,id=c(1,2))
mdatarc<-melt(df_rc,id=c(1,2))
mdatadif<-melt(df_dif,id=c(1,2))

tc<-ggplot(data=mdata,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Total cost over scales")
ni<-ggplot(data=mdatani,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Number of iterations over scales")
rc<-ggplot(data=mdatarc,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Reconstruction error over scales")
dif<-ggplot(data=mdatadif,aes(x=variable,y=value,group=bblid,color=Age)) +geom_line(alpha = 0.15)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark()+labs(title="Non-recon error over scales")


ggarrange(tc,ni,dif,rc)

# plot average recon error over scales
mreconerr<-(colMeans(recon_err)[2:30])
mcrecnerrdf<-data.frame(mreconerr,community_vec)
ggplot(data=mcrecnerrdf,aes(y=mreconerr,x=community_vec))+geom_line(col='white',size=2)+theme_dark(base_size = 28)+ggtitle("Reconstruction Error Over Scales")+ scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Recon. Error")
```

```{r}
# load in FC features (takes about 3 minutes) - original file - not loaded in anymore because it tooks forever and new version is just rounded digits to a few decimal places

fc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats.csv')
oldfc<-vroom('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_old.csv')

# set colnames to matlab-printed colnames
colnames(fc)<-fc[1,]
colnames(oldfc)<-oldfc[1,]
# aaaand remove it
fc<-fc[-c(1),]
oldfc<-oldfc[-c(1),]

# round ridiculous number of decimal points
fc[] <- lapply(fc, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})
oldfc[] <- lapply(oldfc, function(x) {
  if(is.character(x)) round(as.numeric(as.character(x)),digits=3) else x
})

# Baal knows why vroom needs more size for the rounded version
#Sys.setenv("VROOM_CONNECTION_SIZE" = 2000000)
#fc<-read.delim('/cbica/projects/pinesParcels/results/aggregated_data/fc/master_fcfeats_rounded.csv')
# isolate shams (although merge should take them out later)
shams<-fc[694:695,]

### merge FC with subj info
colnames(fc)[1]<-'bblid'
# AGE
masterdf<-merge(fc,demo,by='bblid')

# EF
subjbehav<-read.csv("/cbica/projects/pinesParcels/data/n713_Behavior_20181219.csv")
ef<-data.frame(subjbehav$F1_Exec_Comp_Cog_Accuracy,subjbehav$bblid)
colnames(ef)<-c('F1_Exec_Comp_Cog_Accuracy','bblid')
# merge in
masterdf<-merge(masterdf,ef,by='bblid')
# MOTION METRIC
# courtesty of ZC
# port over ##
Rest_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_RestQAData_20170714.csv")
NBack_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_NBACKQAData_20181001.csv")
Idemo_Motion_Data <- read.csv("/cbica/projects/pinesParcels/data/n1601_idemo_FinalQA_092817.csv")

motmerge<-merge(Rest_Motion_Data,NBack_Motion_Data,by='bblid')
motmerge<-merge(motmerge,Idemo_Motion_Data,by='bblid')
motmerge$Motion <- (motmerge$restRelMeanRMSMotion + motmerge$nbackRelMeanRMSMotion + motmerge$idemoRelMeanRMSMotion)/3;
motiondf<-data.frame(motmerge$bblid,motmerge$Motion)
colnames(motiondf)<-c('bblid','Motion')
masterdf<-merge(masterdf,motiondf,by='bblid')


# potentially obsolete
####masterdf[] <- lapply(masterdf, function(x) {
####  round((x),digits=3)
#####})

### isolate global segreg columns
gsegcols<-grep("globseg",colnames(masterdf))

### plot mean global seg over scales by age
# 2:30 is ind, 5455:5483 is group
indglobseg<-cbind(masterdf$bblid,masterdf$ageAtScan1/12,masterdf$sex,masterdf$Motion,masterdf$F1_Exec_Comp_Cog_Accuracy,masterdf[,2:30])
groglobseg<-cbind(masterdf$bblid,masterdf$ageAtScan1/12,masterdf$sex,masterdf$Motion,masterdf$F1_Exec_Comp_Cog_Accuracy,masterdf[,5455:5483])

# set colnames
colnames(indglobseg)[1:5]<-c("bblid", "Age","Sex","Motion","EF")
colnames(groglobseg)[1:5]<-c("bblid", "Age","Sex","Motion","EF")
colnames(indglobseg)[6:34]<-as.character(2:30)
colnames(groglobseg)[6:34]<-as.character(2:30)
indglobseg$Sex<-as.factor(indglobseg$Sex)
groglobseg$Sex<-as.factor(groglobseg$Sex)

# melt it
mindglobseg<-melt(indglobseg, id=c(1,2))
mgroglobseg<-melt(groglobseg, id=c(1,2))

# individual segregation over scales plots, colored by age ##
indseg<-ggplot(data=mindglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="Global Segregation - Individ. Partitions") + scale_x_continuous(name ="# of Communitites",  breaks=seq(2, 30, 4))+ylab("Global Segregation")
groseg<-ggplot(data=mgroglobseg,aes(x=as.numeric(as.character(variable)),y=value,group=bblid,color=Age)) +geom_line(alpha = 0.12)+scale_color_gradientn(colors=c("yellow","purple")) + theme_dark(base_size = 28)+labs(title="Global Segregation - Group Partitions") + scale_x_continuous(name ="# of Communitites", breaks=seq(2, 30, 4))+ylab("Global Segregation")
ggarrange(indseg,groseg,ncol=1)



# formal t.test for gro seg vs ind seg
indsegvec<-as.vector(unlist(indglobseg[,3:31]))
grosegvec<-as.vector(unlist(groglobseg[,3:31]))
t.test(indsegvec,grosegvec,paired=T)
```

```{r}
### get global seg cors
### Now with motion + sex control
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30
for (i in 1:29){
  # i+5 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  linmod=lm(indglobseg[,i+5]~Sex+Motion,data=indglobseg)
  agecor=(cor.test(linmod$residuals,indglobseg$Age))$estimate
  ind_segcors[i,2]<-agecor
}
## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  # i+5 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  linmod=lm(groglobseg[,i+5]~Sex+Motion,data=groglobseg)
  agecor=(cor.test(linmod$residuals,groglobseg$Age))$estimate
  gro_segcors[i,2]<-agecor
}

indagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - Individ. Partitions")
groagecor<-correlations_over_scales(gro_segcors,"Global Segregation Age Correlation - Group Partitions")
ggarrange(indagecor,groagecor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Age Correlation')+
    theme_dark(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Age Correlation Over Scales")
```
```{r}
### get global seg cors FOR EF
### Now with motion + sex control
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30
for (i in 1:29){
  # i+5 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  linmod=lm(indglobseg[,i+5]~Sex+Motion+Age,data=indglobseg)
  EFcor=(cor.test(linmod$residuals,indglobseg$EF))$estimate
  ind_segcors[i,2]<-EFcor
}
## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  # i+5 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  linmod=lm(groglobseg[,i+5]~Sex+Motion+Age,data=groglobseg)
  EFcor=(cor.test(linmod$residuals,groglobseg$EF))$estimate
  gro_segcors[i,2]<-EFcor
}

indagecor<-correlations_over_scales(ind_segcors,"Global Segregation Age Correlation - Individ. Partitions")
groagecor<-correlations_over_scales(gro_segcors,"Global Segregation Age Correlation - Group Partitions")
ggarrange(indagecor,groagecor,ncol = 1)

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-EF Correlation')+
    theme_dark(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and EF Correlation Over Scales")
```
```{r}
### get global seg -motion cors
# 29 for scales studied
ind_segcors<-matrix(0,29,2)
ind_segcors[,1]<-2:30
for (i in 1:29){
  # i+5 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  linmod=lm(indglobseg[,i+5]~Age+Sex,data=indglobseg)
  motcor=(cor.test(linmod$residuals,indglobseg$Motion))$estimate
  ind_segcors[i,2]<-motcor
}
## now group level
# 29 for scales studied
gro_segcors<-matrix(0,29,2)
gro_segcors[,1]<-2:30
for (i in 1:29){
  # i+5 because first column is scanid, second is age, third is sex, 4th is motion, 5th is EF
  linmod=lm(groglobseg[,i+5]~Age+Sex,data=groglobseg)
  motcor=(cor.test(linmod$residuals,groglobseg$Motion))$estimate
  gro_segcors[i,2]<-motcor
}

# merged
ind_segcors_df<-data.frame(ind_segcors)
gro_segcors_df<-data.frame(gro_segcors)
mergeddf<-merge(ind_segcors_df,gro_segcors_df,by="X1")
colnames(mergeddf)<-c("X1","Individualized","Consensus")
x<-melt(mergeddf,id="X1")
colnames(x)<-c("X1","Partitioning","value")
ggplot(x,aes(X1,value,group=Partitioning,color=Partitioning)) + geom_step(size=3)+ylab('Segregation-Motion Correlation')+
    theme_dark(base_size = 28)+
    theme(axis.text=element_text(), axis.title = element_text(),panel.grid.minor = element_blank(), plot.title = element_text())+
    xlab("# of Communities") + scale_x_continuous(breaks=seq(2, 30, 4)) +
    geom_hline(aes(yintercept=.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=-.098), linetype="dashed", col='#55185D',size=2.5) +
    geom_hline(aes(yintercept=.125), linetype="dashed", col='#ECB602',size=2.5) +
    geom_hline(aes(yintercept=-.125), linetype="dashed", col='#ECB602',size=2.5) + scale_color_manual(values = c("black", "grey"))+ggtitle("Global Segregation and Motion Correlation Over Scales")
```


```{r}

# indicators of processing stream
ind='ind'
gro='gro'
###bts='bts'
###
#### indicators of fc feature type
bwi='_bw_FC_'
wini='_win_FC_'
nsegi='_seg_scale'
###gsegi='_globseg_scale'
###
#### indices of said indicators
indiv=grep(ind,colnames(masterdf))
group=grep(gro,colnames(masterdf))
###basists=grep(bts,colnames(df))
bwcol=grep(bwi,colnames(masterdf))
wincols=grep(wini,colnames(masterdf))
nsegcols=grep(nsegi,colnames(masterdf))
###gsegcols=grep(gsegi,colnames(df))
###
# Make motion-regressed version of everything



###segdf<-merge(gseg,df,by="scanid")
###
###seg_cors<-matrix(0,length(community_vec),2)
###seg_cors[,1]<-community_vec
###
###for (i in 1:length(community_vec)){
###  # i+1 because first column is scanid
###  seg_cors[i,2]<-cor.test(segdf[,i+1],segdf$Age)$estimate
###}
###
###correlations_over_scalesplot(correlations=seg_cors,title="Segregation-Age correlations over Scales")

# multi-scale patterning
# shape analyses

### 29 scales, 2 coordinates (x,y), and 693 subjs
globalseg<-array(0,dim=c(29,2,693))

# for each subject, fill in x and y coords. (x is constant, is scale)
for (i in 1:693){
  # 2-30 as x-axis (scales of obs.)
  globalseg[,1,i]<-seq(2,30)
  # y values as error/cost
  # seems more matlabby than characteristic of R that I have to as.x(as.x(df)) for it to work, but here we are
  globalseg[,2,i]<-as.array(as.matrix(indglobseg[i,3:31]))
  
  # scale SDs to be equiv in x and y dimensions (to enforce principled shape)
  #sd1<-(sd(globalseg[,1,i]))
  #sd2<-(sd(globalseg[,2,i]))
  #globalseg[,1,i]<- globalseg[,1,i] * sd2
  #globalseg[,2,i]<- globalseg[,2,i] * sd1
  
}

seg_procrust<-procGPA(globalseg)

shapepca(seg_procrust, pcno=1, type = "v", mag=16)

# get individ. level pc scores into df
indglobseg$pc1<-seg_procrust$scores[,1]

# find dif b/w scale 2 and 30 for simpler description of shape pc
indglobseg$dif<-indglobseg$`2` - indglobseg$`30`
plot(indglobseg$Age,indglobseg$dif)
## plot demonstrative subjs (highest and lowest PC loading)

### note, shape is captured by dif b/w seg at scale 2 and 30
```

```{r}
### analyze relation of transmodality to segregation over scales
### Get in Consensus-reference atlas correspondence
rac<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_yCorrespondence_overscales.csv',stringsAsFactors = F)
scalesvec<-as.numeric(rac[2,])
domnetvec<-as.factor(rac[3,])
netpropvec<-as.numeric(rac[4,])

#### read in transmodality
tm<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/fc/network_transmodality_overscales.csv',stringsAsFactors = F)
colnames(tm)<-tm[1,]
# aaaand remove it
tm<-tm[-c(1),]
tmvec<-as.numeric(tm)

# distribution of transmodality across networks across scales (derived from group consensus)
hist(tmvec,12,xlab="Transmodality",ylab="Count",ylim=c(0,70), main=NULL,col="grey")

# use median transmodality value to split relatively bimodal distribution
medtrans<-median(tmvec)
# equivalent vector to be overwritten with binary classification of transmodality
tmclass<-tmvec
for (i in 1:length(tmclass)){
  if (tmvec[i]<= medtrans){
    tmclass[i]='unimodal'
  }else{
    tmclass[i]='transmodal'
  }
}

############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
indiv_wincols_ind<-intersect(wincols,indiv)
individ_scalebywin_df<-masterdf[,indiv_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(individ_scalebywin_df)

# will needs these functions throughout
corconfinfvecupper<-function(x){
  confinf<-cor.test(x,masterdf$ageAtScan1)[9]
  return(unlist(confinf)[1])
}
corconfinfveclower<-function(x){
  confinf<-cor.test(x,masterdf$ageAtScan1)[9]
  return(unlist(confinf)[2])
}
corEstVec<-function(x){
  corest<-cor.test(x,masterdf$ageAtScan1)[4]
  return(unlist(corest))
}
corEstVec_EF<-function(x){
  corest<-cor.test(x,masterdf$EF)[4]
  return(unlist(corest))
}


confvecupper<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfvecupper))
confveclower<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_wincols_ind],corEstVec))
confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
confveclower_d[,7]<-CIgroupingInd
confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
colnames(confveclower_d)[2]<-"CIbounds"
colnames(confvecupper_d)[2]<-"CIbounds"
win_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))
# range of interest until we work out K=2 and K=3
indofint<-6:464
indofint<-append(indofint,(470:928))

# plot it
Win_age_tm<-ggplot(win_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_line(size=1) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Network Connectivity and Age over All Networks')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale<-ggplot(win_CIplotdf[indofint,],aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeWinCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)+ ggtitle('Correlation of Within Network Connectivity and Age over All Networks')
```

```{r}
############ analyze contribution of segregation in network connectivities' age couplings by scale and transmodality #############

# pull out scale x network segregation for individualized maps
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
indiv_scalebynet_df<-masterdf[,indiv_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)

confvecupper<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfvecupper))
confveclower<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,indiv_nsegcols_ind],corEstVec))

confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
confveclower_d[,7]<-CIgroupingInd
confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
colnames(confveclower_d)[2]<-"CIbounds"
colnames(confvecupper_d)[2]<-"CIbounds"
Seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))
# range of interest until we work out K=2 and K=3
indofint<-6:464
indofint<-append(indofint,(470:928))


#Segreg_age_tm<-ggplot(Seg_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_line(size=1) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Network Segregation and Age over All Networks')+ ylim(-.5,.5)

# without proportion
Segreg_age_tm<-ggplot(Seg_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,group=V7)) + geom_line(size=1,alpha=.5) + scale_color_manual(name="Predominant \nOverlapping \nYeo7 Network",values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst),alpha=.5) + ggtitle('Correlation of Network Segregation and Age over All Networks')+ ylim(-.5,.5) +theme(legend.text=element_text(size=20))

Segreg_age_tm_point<-ggplot(Seg_CIplotdf[indofint,],aes(tmvec,corVecEst,color=domnetvec,group=V7))+ scale_color_manual(name="Predominant \nOverlapping \nYeo7 Network",values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab('Segregation-Age Correlation') +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst),alpha=.7) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5) +theme(legend.text=element_text(size=20))

Segreg_age_tm_line<-ggplot(Seg_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,group=V7)) + geom_line(size=1,alpha=.5) + scale_color_manual(name="Predominant \nOverlapping \nYeo7 Network",values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab(expression(rho)) +theme_classic(base_size = 28) + ggtitle('Correlation of Network Segregation and Age over All Communities')+ ylim(-.5,.5) +theme(legend.text=element_text(size=20))

Segreg_age_scale<-ggplot(Seg_CIplotdf[indofint,],aes(tmvec,corVecEst,color=scalesvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = 'Transmodality', y = expression(rho), color="Topological \nScale")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")

Segreg_age_scale_x<-ggplot(Seg_CIplotdf,aes(scalesvec,corVecEst,color=tmvec,alpha=.5)) +labs(title='Correlation of Network Segregation and Age over All Communities', x = '# of Communities', y = 'Segregation-Age Correlation', color="Transmodality")+ geom_point(size=4,alpha=.5) +theme_classic(base_size = 28)+ ylim(-.5,.5)+ scale_colour_gradient(low="#55185D", high="#ECB602")



ggarrange(Segreg_age_tm,Segreg_age_scale,Win_age_tm,Win_age_scale)


##name="Predominant Overlapping \n Yeo7 Network")
```

```{r}

### BY THE POWER OF OUR INDICES COMBINED!
indiv_bwcols_ind<-intersect(bwcol,indiv)
individ_scalebybw_df<-masterdf[,indiv_bwcols_ind]
# to later use wincolname -> bwcolname mapping to extrapolate if if network is unimodal or transmodal along bwcol indices
wincolnames<-colnames(individ_scalebywin_df)
bwcolnames<-colnames(individ_scalebybw_df)

# empty array to populate with b/w connectivity age cors (b/w to unimodal, b/w to transmodal, b/w to aggregate, and K and N and Modality just to confirm we are matching)
bwAgeCorVecs<-matrix(0,464,6)

# loop over connectivities to unimodal then to transmodal
modalloopvar=c('unimodal','transmodal')
for (i in 1:2){
  print(modalloopvar[i])
  # get "the other"
  modalloopvar_other=modalloopvar[modalloopvar!=(modalloopvar[i])]
  # extract which of 1:464 network mappings match the modalitity of this loop
  modalindices=which(tmclass %in% modalloopvar[i])
  # loop over each scale
    for (K in 2:30){
    # Make index of where values from this K should go
      K_start=((K-1)*(K))/2
      K_end=(((K-1)*(K))/2)+K-1
      Kind<-K_start:K_end
      bwAgeCorVecs[Kind,4]=K
    
    # index which values are at this scale
    scaleStr=paste('scale',K,'_',sep='')
    scaleCols_inds=grep(scaleStr,colnames(masterdf))
    scaleK_bw_indivi_cols_inds<-intersect(indiv_bwcols_ind,scaleCols_inds)
    # extract within and between colnames at this scale for within->b/w binarized transmodality mapping
    wincolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),wincolnames)
    wincolnames_thisScale=wincolnames[wincolnames_thisScale_inds]
    bwcolnames_thisScale_inds<-grep((paste('scale',K,'_',sep='')),bwcolnames)
    bwcolnames_thisScale=bwcolnames[bwcolnames_thisScale_inds]
    
  # one weird trick to get binarized transmodality class vector for same scale (Doctors hate him!)
    # tm naming aligns with wincon naming
    tmclasses_thisScale<-tmclass[wincolnames_thisScale_inds]
    # extract the network number of each network at this scale in same order as tmclasses_thisScale
    wincolNamesSplit<-strsplit(wincolnames_thisScale,"_net")
    wincolNames_net<-sapply(wincolNamesSplit, "[[" , 2)
    # mini matching vectors with network label at this scale in one col and transmodality binarization in the other
    tmMatchingVecs<-cbind(wincolNames_net,tmclasses_thisScale)
    # remove scale number from strings so we're not picking up on those
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    bwnetnames_thisScale<-wincolNames_net<-sapply(bwcolnames_thisScale_split, "[[" , 2)
    # add another fucking set of underscores to all of these colnames so 1's dont pick up 10s
    bwnetnames_thisScale_extended<-paste('ind_bw_FC_scale',K,'_nets_',bwnetnames_thisScale,'_',sep='')
    # extra goddamn undercores have to go here and be removed later
    bwcolnames_thisScale_split<-strsplit(bwcolnames_thisScale,"nets")
    # to be matched in all-networks-at-this-scale loop
    # now as we descend into the third circle of for-loop hell, we find the guy from man vs.food being eaten alive by cerberus
    for (N in 1:K){
      # generate index for where values for this network at this scale should reside
      # start from K index
      Nind<-Kind[N]
      bwAgeCorVecs[Nind,5]=N
      # get index for this N in terms of masterdf (collapse | to match multiple patterns)
      Ncolname<-grep(as.character(paste('_',N,'_',sep='')),bwnetnames_thisScale_extended,value=T)
      # need to add "_" before and after each number so I can select for '_N_' and not pick up teens digits with 1, 20s with 3, 15 and 25 with 5, etc.
      # determine if this network is transmodal or unimodal
      NModality<-tmMatchingVecs[,2][[N]]
      ########bwAgeCorVecs[Nind,6]<-NModality
      NotNModality<-modalloopvar[modalloopvar!=NModality]
      matchvec<-grep(NModality,tmclasses_thisScale)
      # remove self
      matchvec<-matchvec[matchvec!=N]
      # build index of matching modalities to reference masterdf (collapse | to match multiple patterns)
      matchTruncColName<-grep(as.character(paste('_',matchvec,'_',sep='',collapse="|")),Ncolname,value=T)
      # remove first and last characters now that we are specific
      #matchTruncColName<-sub('.$','',matchTruncColName)
      #matchTruncColName<-sub('.','',matchTruncColName)
      # deal with weird thing where empty space was being grepped because of its aspecificity at coarse scales
      if(length(matchTruncColName)==0){
        matchTruncColName[1]='CANTSEEME'
      }
      match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(matchTruncColName,collapse="|")),bwnetnames_thisScale_extended)
      match_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[match_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      
      # deal with weird thing where empty space was being grepped because of its aspecificity
      if(length(match_NetN_scaleK_bw_indivi_cols_names)==0){
        match_NetN_scaleK_bw_indivi_cols_names[1]='CANTSEEME'
      }
      #################
      #### NEED TO ADD UNDERSCORE TO AFTERPORTION SO IT DOESNT PICK UP 1_20 when looking for 1_2 #########
      ##########
      #bwcolnames_thisScale<-paste(bwcolnames_thisScale,'_',sep='')
      #match_NetN_scaleK_bw_indivi_cols_names<-paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='')
      
      # added a faux '_' to end of column to col names can more selectively match numbers (not picking up on 20 when looking for 2, 2_ and 20_ more distinct)
      match_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(match_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
    
      ###############
      ######## find opposite modality in this scale ################
      ###############
      
      oppositevec<-grep(NotNModality,tmclasses_thisScale)
      
      # build index of NON-matching modalities to reference masterdf (collapse | to match multiple patterns)
      unmatchTruncColName<-grep(as.character(paste('_',oppositevec,'_',sep='',collapse="|")),Ncolname,value=T)
      # search for string in limited bwcolnames at this scale so as not to invite other scales into this grep party
      # remove first and last characters now that we are specific
      #unmatchTruncColName<-sub('.$','',unmatchTruncColName)
      #unmatchTruncColName<-sub('.','',unmatchTruncColName)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-grep(as.character(paste(unmatchTruncColName,collapse="|")),bwnetnames_thisScale_extended,value=T)
      
      # deep-sea grepping the whole paste and pipe thing is just to deal with character vectors instead of single patterns
      unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,collapse="|")),bwnetnames_thisScale_extended)
      unmatch_NetN_scaleK_bw_indivi_cols_names<-bwcolnames_thisScale[unmatch_NetN_scaleK_bw_indivi_cols_ind_within_other_ind]
      unmatch_NetN_scaleK_bw_indivi_cols_ind<-grep(as.character(paste(unmatch_NetN_scaleK_bw_indivi_cols_names,'_',sep='',collapse="|")),paste(colnames(masterdf),'_',sep=''))
      
      
      # doublecheck that they are mutually exclusive (+1 because self-reference gets removed)
    #  if(length(tmclasses_thisScale)!=length(matchvec)+length(oppositevec)+1){
   #     print('You done goofed, internet police are on their way')
     # }
      if(length(tmclasses_thisScale)!=length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1){
        print('Names dont add up chief')
        paste('match numbas', length(match_NetN_scaleK_bw_indivi_cols_ind), length(match_NetN_scaleK_bw_indivi_cols_names))
        paste('unmatch numbas', length(unmatch_NetN_scaleK_bw_indivi_cols_ind), length(unmatch_NetN_scaleK_bw_indivi_cols_names))
        stopifnot(length(tmclasses_thisScale)==length(match_NetN_scaleK_bw_indivi_cols_ind)+length(unmatch_NetN_scaleK_bw_indivi_cols_ind)+1)
      }
      unmatch_NetN_scaleK_bw_indivi_cols_ind
      # Reset these to NULL for each loop over N for equivalent looping
      
      
      # if it matches the modality being aggregated in the grandparent loop, we wish to only assay its connections to same-modality networks
      if (NModality==modalloopvar[i] && length(matchvec>0)){
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_same<-rowMeans(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind,drop=F])
        # get mean agecor with matching networks
        avg_bw_agecor<-unlist(cor.test(avg_bw_same,masterdf$ageAtScan1)[4])
      } else if (NModality!=modalloopvar[i]) {  
        avg_bw_agecor<-NULL
        # get average value of b/w but same modality connectivity
        avg_bw_dif<-rowMeans(masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
        # get mean agecor with non-matching networks
        avg_bw_agecor<-unlist(cor.test(avg_bw_dif,masterdf$ageAtScan1)[4])
      } else if (NModality==modalloopvar[i] && (exists("matchvec[1]"))=='FALSE') {
        # easily findable index for cells which should not be filled (i.e., there is no "to unimodal connectivity" for the only unimodal networks at any scale)
        avg_bw_agecor<-999
      }
      # if it does not match the modality of the grandparent loop, we wish go assay its connections to opposite-modality networks
      bwAgeCorVecs[Nind,i]=avg_bw_agecor
    # get average bw network connectivty age correlation for this network at this scale
      both=cbind(masterdf[,match_NetN_scaleK_bw_indivi_cols_ind],masterdf[,unmatch_NetN_scaleK_bw_indivi_cols_ind, drop=F])
      avg_bw=rowMeans(both)
      avg_bw_coarse_agecor<-cor.test(avg_bw,masterdf$ageAtScan1)[4]
      bwAgeCorVecs[Nind,3]=unlist(avg_bw_coarse_agecor)
    }
    # Print out ratio of transmodal to unimodal at this scale
    unilength=length(tmclasses_thisScale[tmclasses_thisScale=='unimodal'])
    translength=length(tmclasses_thisScale[tmclasses_thisScale=='transmodal'])
    print(paste('uni to trans ratio:', unilength/translength))
  }
  
}
bwAgeCorVecs<-data.frame(bwAgeCorVecs)
```

```{r}


# analyze between network connectivities' couplings with age by transmodality
colnames(bwAgeCorVecs)<-c('bw_to_unimodal','bw_to_transmodal','avg_bw','K','N')
############ analyze contribution of avg b/w network connectivities' age couplings by scale and transmodality #############

# ensure 464 length (number of scale by net features)
length(indiv_scalebynet_df)
bwdf<-data.frame(tmvec,scalesvec,domnetvec,netpropvec,bwAgeCorVecs$avg_bw,bwAgeCorVecs$bw_to_unimodal,bwAgeCorVecs$bw_to_transmodal)

# range of interest until we work out K=2 and K=3
indofint<-6:464


# avg b/w
avgbw_age_tm<-ggplot(bwdf[indofint,],aes(tmvec,bwAgeCorVecs.avg_bw,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w con avg and Age over All Networks') + ylim(-.5,.5)

avgbw_age_scale<-ggplot(bwdf[indofint,],aes(tmvec,bwAgeCorVecs.avg_bw,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# b/w to unimodal
unibw_age_tm<-ggplot(bwdf[indofint,],aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWUCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w unimodal con and Age over All Networks')+ ylim(-.5,.5)

unibw_age_scale<-ggplot(bwdf[indofint,],aes(tmvec,bwAgeCorVecs.bw_to_unimodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWUCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# b/w to transmodal
transbw_age_tm<-ggplot(bwdf[indofint,],aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=domnetvec,alpha=netpropvec^2)) + geom_point(size=6)+ scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeBWTCor") +theme_classic(base_size = 28) + ggtitle('Correlation of B/w transmodal con and Age over All Networks')+ ylim(-.5,.5)

transbw_age_scale<-ggplot(bwdf[indofint,],aes(tmvec,bwAgeCorVecs.bw_to_transmodal,color=scalesvec)) + geom_point(size=6) + xlab("Transmodality") + ylab("AgeBWTCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

ggarrange(avgbw_age_tm,unibw_age_tm,transbw_age_tm,avgbw_age_scale,unibw_age_scale,transbw_age_scale)
```

```{r}
#### now make it for group template-measured FC vaues, starting with within and segreg
############ analyze contribution of W/IN network connectivities' age couplings by scale and transmodality #############
gro_wincols_ind<-intersect(wincols,group)
group_scalebynet_df<-masterdf[,gro_wincols_ind]
# ensure 464 length (number of scale by net withincon features)
length(group_scalebynet_df)


confvecupper<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfvecupper))
confveclower<-as.numeric(lapply(masterdf[,gro_wincols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,gro_wincols_ind],corEstVec))
confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
confveclower_d[,7]<-CIgroupingInd
confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
colnames(confveclower_d)[2]<-"CIbounds"
colnames(confvecupper_d)[2]<-"CIbounds"
gro_win_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))
# range of interest until we work out K=2 and K=3
indofint<-6:464
indofint<-append(indofint,(470:928))

# plot it
Win_age_tm_gro<-ggplot(gro_win_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_line(size=1) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeWithinCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Within Connectivity and Age over All Networks (GRO)')+ ylim(-.5,.5)

# check for scale-specific effects
Win_age_scale_gro<-ggplot(gro_win_CIplotdf[indofint,],aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)

# pull out scale x network segregation for individualized maps
gro_nsegcols_ind<-intersect(nsegcols,group)
gro_scalebynet_df<-masterdf[,gro_nsegcols_ind]
# ensure 464 length (number of scale by net features)
length(gro_scalebynet_df)

confvecupper<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corconfinfvecupper))
confveclower<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corconfinfveclower))
corVecEst<-as.numeric(lapply(masterdf[,gro_nsegcols_ind],corEstVec))

confveclower_d<-data.frame(tmvec,confveclower,scalesvec,domnetvec,netpropvec,corVecEst)
confvecupper_d<-data.frame(tmvec,confvecupper,scalesvec,domnetvec,netpropvec,corVecEst)
confvecdf<-data.frame(confveclower_d = confveclower_d, confvecupper_d  = confvecupper_d)

# augment dataframe for CI range plot
CIgroupingInd<-as.factor(1:464)
confveclower_d[,7]<-CIgroupingInd
confvecupper_d[,7]<-CIgroupingInd
#corVecEst_d[,6]<-CIgroupingInd
colnames(confveclower_d)[2]<-"CIbounds"
colnames(confvecupper_d)[2]<-"CIbounds"
gro_seg_CIplotdf<-data.frame(rbind(confveclower_d,confvecupper_d))
# range of interest until we work out K=2 and K=3
indofint<-6:464
indofint<-append(indofint,(470:928))


Segreg_age_tm_gro<-ggplot(gro_seg_CIplotdf[indofint,],aes(tmvec,CIbounds,color=domnetvec,alpha=netpropvec^2,group=V7)) + geom_line(size=1) + scale_color_manual(values=c('#007500','#c1253c','#d77d00','#b8cf86','#3281ab','#b61ad0','#670068')) + xlab("Transmodality") + ylab("AgeSegregCor") +theme_classic(base_size = 28) + geom_point(size=4,aes(tmvec,corVecEst)) + ggtitle('Correlation of Segregation and Age over All Networks (GRO)')+ ylim(-.5,.5)

Segreg_age_scale_gro<-ggplot(gro_seg_CIplotdf[indofint,],aes(tmvec,corVecEst,color=scalesvec)) + geom_point(size=4) + xlab("Transmodality") + ylab("AgeSegregCor")+theme_classic(base_size = 28)+ ylim(-.5,.5)


ggarrange(Segreg_age_tm_gro,Segreg_age_scale_gro,Win_age_tm_gro,Win_age_scale_gro)
```

```{r}
# get the gang together
indiv_nsegcols_ind<-intersect(nsegcols,indiv)
gro_nsegcols_ind<-intersect(nsegcols,group)

# functions to write out the corvec estimates for matlab-based viz
corEstVecNsave<-function(x,K,vecIn){
  corest<-cor.test(x,masterdf$ageAtScan1)[4]
  val<-unlist(corest)
  append(vecIn,val)
}
corEstVec_EFNsave<-function(x,K,vecIn){
  corest<-cor.test(x,masterdf$F1_Exec_Comp_Cog_Accuracy)[4]
  val<-unlist(corest)
  append(vecIn,val)
}


# loop over scales
for (i in 2:30){
  print(i)
  keyphrase<-paste('seg_scale',as.character(i),'_net',sep='')
  scaleind=grep(keyphrase,colnames(masterdf))
  # just individualized for now
  # reads in vector of segreg vals aligned with age vals and scale 
  vec_age<-NULL
  vec_age<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],corEstVecNsave,K=i,vecIn=vec_age)
  vecfp_Age<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_Age.csv',sep='')
  write.table(as.numeric(vec_age),vecfp_Age,row.names = F,col.names = F,sep = ',')
  vec_ef<-NULL
  vec_ef<-lapply(masterdf[,intersect(indiv_nsegcols_ind,scaleind)],corEstVec_EFNsave,K=i,vecIn=vec_ef)
  vecfp_EF<-paste('/cbica/projects/pinesParcels/results/EffectVecs/',as.character(i),'_EF.csv',sep='')
  write.table(as.numeric(vec_ef),vecfp_EF,row.names = F,col.names = F,sep = ',')
}


indiv_scalebynet_df<-masterdf[,indiv_nsegcols_ind]
# isolate scales
scale2ind=grep('seg_scale2_net',colnames(masterdf))
scale16ind=grep('seg_scale16_net',colnames(masterdf))
scale25ind=grep('seg_scale25_net',colnames(masterdf))

# eval age assoc w/ segreg at each scale
corVecEst_2<-as.numeric(lapply(masterdf[,intersect(gro_nsegcols_ind,scale2ind)],corEstVec))
corVecEst_16<-as.numeric(lapply(masterdf[,intersect(indiv_nsegcols_ind,scale16ind)],corEstVec))
corVecEst_25<-as.numeric(lapply(masterdf[,intersect(indiv_nsegcols_ind,scale25ind)],corEstVec))
corVecEst_2_EF<-as.numeric(lapply(masterdf[,intersect(gro_nsegcols_ind,scale2ind)],corEstVec_EF))
corVecEst_16_EF<-as.numeric(lapply(masterdf[,intersect(indiv_nsegcols_ind,scale16ind)],corEstVec_EF))
corVecEst_25_EF<-as.numeric(lapply(masterdf[,intersect(indiv_nsegcols_ind,scale25ind)],corEstVec_EF))



# Write em out as matlab readable vectors (K: N1est N2est ... Nnest)

```

```{r}
# load gradstats
grad_sum_df<-read.csv('/cbica/projects/pinesParcels/lambdas_pg1.csv',header=F)
age<-data.frame(demo$ageAtScan1,demo$bblid)
colnames(grad_sum_df)<-c("bblid","grad1lambda")
colnames(age)<-c("age","bblid")
grad_sum_df$bblid<-as.integer(grad_sum_df$bblid)
merged_df<-merge(grad_sum_df,age,by="bblid")

# load grad-dm-cors
graddmcor<-read.csv('/cbica/projects/pinesParcels/results/aggregated_data/SpatialCorIndK3DMPG1.csv',header=F);
# temp exlcusion of misreads
tmpexcl<-graddmcor[graddmcor[,2]<0.35,1]
#100869 106154 107929 109577 110166 110354 118807 120922 121017 122352 122669 127305 130121 130332 131747  80537  83207
#86690  88190  88859  89063  89534  96201  98879
tempexclind<-which(tmpexcl %in% merged_df$bblid)
merged_df_tmpexcl=merged_df[-c(tempexclind),]
testfordmseg<-merge(merged_df_tmpexcl, f , by="Subjects")
masterdf$Subjects<-as.factor(masterdf$Subjects)
merged_df_tmpexcl$Subjects<-as.factor(merged_df_tmpexcl$Subjects)
```
```
